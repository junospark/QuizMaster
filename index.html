<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Interactive Quiz</title>
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.6/dist/purify.min.js"></script>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <style>
    /* Browser-Standard-Basis mit modernen Erg√§nzungen */
    * { box-sizing: border-box; }
    html, body {
  margin: 0;
  padding: 0;
  font-family: -webkit-system-font, system-ui, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
  line-height: 1.5;
  color-scheme: dark;
  background: var(--bg);
  color: var(--text);
  min-height: 100vh;
}
    body { padding: 20px; max-width: 1400px; margin: 0 auto; }
  main, quiz-card, editor, importer, progress, edit-modal, preview-modal {
    padding: 16px;
    margin-top: 12px;
  }
/* Container */
    #main, #quiz-card, #editor, #importer, #progress, #edit-modal, #preview-modal {
      margin-top: 20px; padding: 20px; border: 1px solid var(--border); border-radius: 8px;
      background: var(--surface); box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }

    /* Dashboard */
    .dashboard-grid { display:grid; grid-template-columns:1fr 1fr; gap:20px; margin-top:20px; }
    .dashboard-card { padding:16px; border: 1px solid var(--border); border-radius:8px; background: var(--surface); box-shadow:0 2px 8px rgba(0,0,0,0.05); }
    .dashboard-header { display:flex; justify-content:space-between; align-items:center; margin-bottom:20px; padding-bottom:16px; }
    .settings-panel {
      display:grid; grid-template-columns:repeat(auto-fit,minmax(200px,1fr));
      gap:16px; margin-bottom:20px; padding:16px;
      background: color-mix(in srgb, Field 95%, blue 5%);
      border-radius:8px; border: 1px solid var(--border);
    }

    .progress-bar { width:100%; height:20px; background: color-mix(in srgb, Field 80%, gray 20%); border-radius:10px; overflow:hidden; margin:8px 0; }
    .progress-fill { height:100%; border-radius:10px; transition: width 0.3s ease; }
    .progress-fill.good{background:linear-gradient(90deg,#4ade80,#22c55e);}
    .progress-fill.warning{background:linear-gradient(90deg,#fbbf24,#f59e0b);}
    .progress-fill.danger{background:linear-gradient(90deg,#f87171,#ef4444);}

    .stats-grid { display:grid; grid-template-columns:repeat(auto-fit,minmax(150px,1fr)); gap:12px; margin:16px 0; }
    .stat-item { text-align:center; padding:12px; background: var(--surface); border-radius:8px; border:1px solid color-mix(in srgb, ButtonBorder 80%, blue 20%); }
    .stat-value { font-size:1.8em; font-weight:bold; color: color-mix(in srgb, CanvasText 70%, blue 30%); }
    .stat-label { font-size:0.9em; margin-top:4px; }

    .chart-container { position:relative; height:300px; margin:16px 0; }

    .theme-progress { margin-bottom:16px; padding:12px; background: color-mix(in srgb, Field 95%, transparent 5%); border-radius:6px; border:1px solid color-mix(in srgb, ButtonBorder 90%, transparent 10%); }
    .theme-header { display:flex; justify-content:space-between; align-items:center; margin-bottom:8px; }
    .theme-name { font-weight:600; color: color-mix(in srgb, CanvasText 80%, blue 20%); }
    .theme-stats { font-size:0.9em; opacity:0.8; }

    h1,h2,h3,h4,h5,h6 { color: var(--text); margin:0 0 16px 0; font-weight:600; }

    button {
      font-family:inherit; font-size:inherit; padding:8px 16px; margin:4px 8px 4px 0;
      border: 1px solid var(--border); border-radius:4px; background: var(--surface); color: var(--text); cursor:pointer; transition: all 0.15s ease;
    }
    button:hover{background: color-mix(in srgb, ButtonFace 85%, CanvasText 15%); border-color: color-mix(in srgb, ButtonBorder 70%, CanvasText 30%);}
    button:active{background: color-mix(in srgb, ButtonFace 75%, CanvasText 25%); transform: translateY(1px);}
    button:focus{outline: 2px solid var(--accent); outline-offset:2px;}
    button[disabled]{opacity:.6; cursor:not-allowed; filter:grayscale(.6); background: color-mix(in srgb, ButtonFace 90%, gray 10%); color:GrayText; border-color: color-mix(in srgb, ButtonBorder 70%, gray 30%);}
    #check-btn[disabled]{background: color-mix(in srgb, ButtonFace 85%, gray 15%);}

    /* Make the "Check" button larger than other buttons for prominence */
    #check-btn{
      font-size: 1.1em;
      padding: 12px 24px;
    }

    input, textarea, select {
      font-family:inherit; font-size:inherit; padding:6px 8px; margin:4px 0;
      border: 1px solid var(--border); border-radius:4px; background: var(--surface); color: var(--text);
    }
    input:focus, textarea:focus, select:focus { outline: 2px solid var(--accent); outline-offset:1px; border-color:Highlight; }
    .input-group { display:flex; flex-direction:column; gap:4px; }
    .input-group label{ font-weight:500; font-size:0.9em; }

    /*
      Override the default "delete-all" button styling. This button is used
      for destructive actions like removing all questions. In the dark
      interface it has a neutral (nearly black) background by default and
      only turns red when hovered to draw the user's attention to the
      danger of the action.
    */
    .delete-all-btn {
      background: #000;
      color: var(--text);
      border: 1px solid var(--border);
    }
    .delete-all-btn:hover {
      background: var(--danger);
      color: var(--bg);
      border-color: var(--danger);
    }

    #add-ans-btn, .delete-ans-btn { font-size:1.2em; border:none; background:none; color: color-mix(in srgb, CanvasText 70%, blue 30%); cursor:pointer; padding:4px; }
    #add-ans-btn:hover, .delete-ans-btn:hover { color: color-mix(in srgb, CanvasText 50%, red 50%); }

    .answer { display:flex; align-items:center; margin-bottom:8px; gap:8px; }
    /*
     * Antwort-Felder im Bearbeitungsdialog verwenden einen
     * contenteditable <div> mit der Klasse "richbox" (siehe bindEditable()).
     * Die Basisklasse .richbox ist f√ºr gr√∂√üere Fragetexte ausgelegt
     * und hat ein Mindestma√ü von 70px. F√ºr die kurzen Antwortfelder
     * wird dieses Styling hier √ºberschrieben: sie sollen flexibel
     * in der Breite aufziehen, eine kleinere Mindesth√∂he besitzen
     * und die bekannte dunkel gl√§nzende Optik erhalten.
     */
    .answer .richbox {
      flex: 1;
      min-height: 2.5em;
      resize: vertical;
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 8px;
      background: var(--surface);
      color: var(--text);
    }
    .answer .richbox:focus {
      outline: 2px solid var(--accent);
      outline-offset: 1px;
    }

    .correct { color: color-mix(in srgb, CanvasText 40%, green 60%); font-weight:bold; }
    .wrong { color: color-mix(in srgb, CanvasText 40%, red 60%); font-weight:bold; }

    .comment-btn.active { background: color-mix(in srgb, ButtonFace 70%, yellow 30%); border-color: color-mix(in srgb, ButtonBorder 50%, orange 50%); }
    .comment-btn[disabled] { background: color-mix(in srgb, ButtonFace 90%, gray 10%); color:GrayText; cursor:not-allowed; }

    .scroll-table-container { width:100%; max-width: calc(100vw - 80px); overflow:auto; height:55vh; min-height:200px; border: 1px solid var(--border); border-radius:6px; background: var(--surface); }
    /* Use auto table layout so columns adapt to the available space. Avoid fixed minimum widths to allow responsive scaling */
    table { border-collapse:collapse; width:100%; table-layout:auto; font-size:0.95em; }
    th, td { border:1px solid color-mix(in srgb, ButtonBorder 80%, transparent 20%); padding:8px 12px; text-align:left; background: var(--surface); }
    th { background: color-mix(in srgb, Field 85%, CanvasText 15%); position:sticky; top:0; z-index:2; font-weight:600; }
    tr:hover td { background: color-mix(in srgb, Field 90%, Highlight 10%); }

    .delete-q-btn { background:none; border:none; cursor:pointer; font-size:1.2em; color: color-mix(in srgb, CanvasText 60%, red 40%); padding:2px 4px; }
    .delete-q-btn:hover { color: color-mix(in srgb, CanvasText 40%, red 60%); }

    table .missing-solution-row td { background: color-mix(in srgb, Field 70%, yellow 30%) !important; }
    table .missing-solution-row:hover td { background: color-mix(in srgb, Field 50%, yellow 50%) !important; }
    table .partial-match-row td { background: color-mix(in srgb, Field 70%, orange 30%) !important; }
    table .partial-match-row:hover td { background: color-mix(in srgb, Field 50%, orange 50%) !important; }

    #edit-modal, #preview-modal {
      position:fixed; left:0; top:0; width:100vw; height:100vh; display:none;
      align-items:center; justify-content:center; background: color-mix(in srgb, Canvas 20%, transparent 80%);
      backdrop-filter: blur(2px); z-index:9999;
    }
    #modal-content, #preview-content {
      background: var(--bg); border: 2px solid var(--border); border-radius:12px; padding:24px;
      width:min(950px, 90vw); max-height:90vh; overflow:auto; box-shadow:0 8px 32px rgba(0,0,0,0.2); position:relative;
      /* Editorfenster darf skaliert werden */
      resize: both;
    }

    .native-dialog { position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); background: var(--bg); border: 2px solid var(--border); border-radius:8px; padding:20px; min-width:300px; max-width:500px; box-shadow:0 4px 20px rgba(0,0,0,0.3); z-index:10000; color: var(--text); display:none; }
    .native-dialog-overlay { position:fixed; top:0; left:0; width:100vw; height:100vh; background: color-mix(in srgb, Canvas 30%, transparent 70%); z-index:9999; display:none; }
    .native-dialog h4{ margin:0 0 12px 0; color: var(--text); }
    .native-dialog p{ margin:12px 0; line-height:1.4; }
    .native-dialog-buttons{ text-align:right; margin-top:16px; display:flex; gap:8px; justify-content:flex-end; }
    .modal-header { cursor:move; padding:0 0 16px 0; border-bottom:1px solid ButtonBorder; margin-bottom:16px; user-select:none; }

    .quiz-top { margin-bottom:16px; display:flex; gap:16px; flex-wrap:wrap; }
    #quiz-card .answer { font-size:1.1em; gap:12px; margin-bottom:12px; }
    #quiz-card .answer input[type="checkbox"] { transform: scale(1.2); }

    @media (max-width: 768px) {
      body{padding:12px;} .dashboard-grid{grid-template-columns:1fr; gap:16px;}
      .settings-panel{grid-template-columns:1fr; gap:12px;}
      .stats-grid{grid-template-columns:repeat(2,1fr);}
      #main, #quiz-card, #editor, #importer, #progress{padding:16px; margin-top:12px;}
      .scroll-table-container{max-width: calc(100vw - 32px);}
      /* on small screens shrink table columns; no fixed minimum width */
      table, th, td { font-size:0.9em; }
      #modal-content, #preview-content { width:95vw; padding:16px; }
      .quiz-top{flex-direction:column; gap:8px;}
      button{padding:10px 16px; margin:6px 6px 6px 0;}
      .native-dialog{min-width:280px; max-width:90vw; padding:16px;}
    }
    /* sanfte Hervorhebung der zuletzt bearbeiteten Zeile */
    .flash-highlight { animation: flash-bg 1.2s ease-out 1; }
    @keyframes flash-bg {
    0%   { background: color-mix(in srgb, Field 60%, yellow 40%); }
    100% { background: transparent; }
    }
    .rte-toolbar{display:flex;gap:6px;flex-wrap:wrap;margin:8px 0}
    .rte-toolbar button,input[type="color"],select{padding:6px 8px}

    /* Draw subtle boxes around groups of formatting controls in the rich text editor.  
       This improves visual separation between colour pickers, background colours and table tools. */
    .rte-group {
      display: flex;
      align-items: center;
      gap: 4px;
      border: 1px solid var(--border);
      border-radius: 4px;
      padding: 4px;
      margin-right: 6px;
      background: var(--panel)
    }

    /* Highlight differences when comparing existing questions with imported ones.  
       "Old" values are tinted red and "New" values teal to quickly spot changes. */
    .diff-old { background: color-mix(in srgb, Field 75%, red 25%); }
    .diff-new { background: color-mix(in srgb, Field 75%, lightseagreen 25%); }

    /* Gruppierungen in der schwebenden RTE‚ÄëToolbar.  Durch die Angabe
       einer 100% Breite wird eine neue Zeile begonnen. Jede Gruppe
       enth√§lt ihre eigenen Bedienelemente (Farben, Tabellenfunktionen etc.). */
    .rte-toolbar .rte-group {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
      align-items: center;
      margin-top: 6px;
      width: 100%;
    }
    .rte-toolbar .rte-group .label {
      font-size: 0.85em;
      font-weight: 500;
      margin-right: 4px;
      opacity: 0.8;
    }

    /* Der Fortschrittsbereich zeigt links den aktuellen Stand und
       rechts Dateiname sowie √Ñnderungsdatum. Flexbox sorgt f√ºr
       saubere Aufteilung. */
    #progress {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 1em;
      gap: 12px;
    }
    .richbox{border: 1px solid var(--border);border-radius:6px;padding:8px;background: var(--surface);min-height:70px}
    .richbox:focus{outline: 2px solid var(--accent);outline-offset:1px}
    
    /* Sorgt f√ºr saubere Abst√§nde in angezeigten Kommentaren */
    .comment-body p,
    .comment-body div,
    .comment-body li { margin: 0 0 .5em 0; }
    .comment-body p:last-child,
    .comment-body div:last-child,
    .comment-body li:last-child { margin-bottom: 0; }
  
   #modal-content #qcomment.richbox {
    min-height: 220px;
    max-height: 60vh;
    overflow: auto;
    background: var(--panel);

  }
 /* Floating-WYSIWYG ‚Äì gr√∂√üer + frei skalierbar */
.rte-float{
  position:fixed; top:12px; left:12px; z-index:100000; display:none;
  background: var(--surface); border: 1px solid var(--border); border-radius:10px;
  box-shadow:0 10px 25px rgba(0,0,0,.25);
  padding:10px;
  min-width:420px;            /* vorher 280px */
  max-width:90vw;
  font-size:14px;
  min-height:100px;              
  resize:both; overflow:auto; /* per Maus vergr√∂√üerbar */
}
.rte-float .rte-header{
  cursor:move; user-select:none; font-weight:600;
  padding:6px 8px; border-bottom:1px solid ButtonBorder; margin:-10px -10px 10px -10px;
  background: color-mix(in srgb, Field 90%, CanvasText 10%);
  display:flex; justify-content:space-between; align-items:center;
  min-height:36px;
}
.rte-float .rte-header .right button{ height:28px; width:28px; padding:0; }
.rte-float .rte-toolbar{ display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
.rte-float .rte-toolbar button,
.rte-float .rte-toolbar select,
.rte-float .rte-toolbar input[type="color"]{
  height:32px; line-height:30px; padding:0 10px;
}
.rte-float input[type="color"]{ width:36px; padding:0; }
.rte-float .rte-header { touch-action: none; }
.rte-float { will-change: left, top; }

  
    /* ===================== Dark Mode Customisation ===================== */
    /*
      Glossy Black & Teal palette applied across the entire interface. We
      define a set of CSS custom properties for backgrounds, text colours,
      borders and accent hues, then override the existing component
      definitions. These values produce a modern dark appearance with
      teal highlights that remain functional for all existing behaviours.
    */
    :root {
      --bg: #0d0f10;
      --surface: #13171c;
      --panel: #1a1f24;
      --border: #2c323a;
      --text: #e2e8f0;
      --text-muted: #94a3b8;
      --accent: #14b8a6;
      --accent-hover: #0d9488;
      --danger: #ef4444;
      --warning: #f59e0b;
      --info: #22d3ee;
    }
    html, body {
      color-scheme: dark;
      background: var(--bg);
      color: var(--text);
    }
    /* panels and containers */
    #main, #quiz-card, #editor, #importer, #progress, #edit-modal, #preview-modal {
      background: var(--panel);
      border-color: var(--border);
      box-shadow: 0 2px 8px rgba(0,0,0,0.6);
    }
    .dashboard-card, .settings-panel {
      background: var(--surface);
      border-color: var(--border);
    }
    .settings-panel {
      background: #152027;
    }
    /* text styling */
    h1, h2, h3, h4, h5, h6 { color: var(--text); }
    .stat-value { color: var(--accent); }
    .stat-label { color: var(--text-muted); }
    /* form elements */
    input, textarea, select {
      background: var(--surface);
      color: var(--text);
      border: 1px solid var(--border);
    }
    input:focus, textarea:focus, select:focus {
      outline: 2px solid var(--accent);
      outline-offset: 0;
    }
    /* buttons */
    button, .primary-btn {
      background: var(--surface);
      border: 1px solid var(--border);
      color: var(--text);
      padding: 6px 12px;
      border-radius: 6px;
      transition: background 0.2s ease, color 0.2s ease;
    }
    button:hover, .primary-btn:hover {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
    }
    .danger-btn {
      background: var(--danger);
      color: var(--bg);
      border-color: var(--danger);
    }
    .danger-btn:hover {
      background: #b91c1c;
    }
    .warning-btn {
      background: var(--warning);
      color: var(--bg);
      border-color: var(--warning);
    }
    .warning-btn:hover {
      background: #d97706;
    }
    /* progress bars */
    .progress-bar {
      background: var(--surface);
      border-radius: 10px;
    }
    .progress-fill.good {
      background: linear-gradient(90deg, var(--accent), var(--accent-hover));
    }
    .progress-fill.warning {
      background: linear-gradient(90deg, var(--warning), #d97706);
    }
    .progress-fill.danger {
      background: linear-gradient(90deg, var(--danger), #b91c1c);
    }
    /* table styling */
    table { color: var(--text); }
    th, td {
      background: var(--surface);
      border-color: var(--border);
    }
    tbody tr:hover {
      background: rgba(20,184,166,0.2);
    }
    /* modal overlay adjustments */
    #edit-modal, #preview-modal {
      backdrop-filter: blur(2px);
    }
    /* chart line colours are set via JS, so we leave Chart.js config unchanged here */
    /* =================== End Dark Mode Customisation =================== */

    /* ------------------- Customisations for user requests ------------------- */
    /* Make input groups in the settings panel look like equally sized tiles */
    .settings-panel .input-group {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 12px;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      min-height: 100px;
    }
    .settings-panel .input-group label {
      margin-bottom: 4px;
      color: var(--text);
    }
    .settings-panel .input-group input,
    .settings-panel .input-group select,
    .settings-panel .input-group button {
      width: 100%;
    }

    /* Darken the labels of the statistic tiles on the dashboard */
    .stat-label {
      color: var(--text);
      opacity: 0.6;
    }

    /* Darker background for theme progress cards and lighter text within */
    .theme-progress {
      background: var(--surface);
      border-color: var(--border);
    }
    .theme-name {
      color: var(--text);
    }
    .theme-stats {
      color: var(--text-muted);
      opacity: 0.8;
    }

    /* Improve mobile layout: utilise full height and scale statistic tiles */
    @media (max-width: 768px) {
      html, body {
        min-height: 100vh;
      }
      .stat-item {
        min-height: 80px;
      }
    }

    /* Style for the RTE toggle button on mobile. It appears next to editable
       fields and allows users to manually open the rich text toolbox. */
    .rte-toggle-btn {
      margin-top: 4px;
      background: var(--surface);
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 4px;
      padding: 4px 6px;
      font-size: 1.1em;
      cursor: pointer;
    }
    .rte-toggle-btn:hover {
      background: var(--accent);
      color: var(--bg);
    }

    /*
      Custom button styles for the dashboard and editor.
      These classes augment the generic button styling defined earlier to
      provide visual hierarchy (large vs small) and appropriate hover
      states for critical actions. They rely on a dark base colour by
      default and transition to accent/warning/danger colours on hover.
    */
    .header-big-btn {
      font-size: 1.1em;
      padding: 10px 20px;
      background: #000;
      color: var(--text);
      border: 1px solid var(--border);
    }
    .header-big-btn:hover {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
    }
    .header-small-reset-btn {
      font-size: 0.9em;
      padding: 6px 12px;
      background: #000;
      color: var(--text);
      border: 1px solid var(--border);
    }
    .header-small-reset-btn:hover {
      background: var(--warning);
      color: var(--bg);
      border-color: var(--warning);
    }
    .header-small-delete-btn {
      font-size: 0.9em;
      padding: 6px 12px;
      background: #000;
      color: var(--text);
      border: 1px solid var(--border);
    }
    .header-small-delete-btn:hover {
      background: var(--danger);
      color: var(--bg);
      border-color: var(--danger);
    }
    .editor-reset-btn {
      background: #000;
      color: var(--text);
      border: 1px solid var(--border);
      font-size: 0.9em;
      padding: 6px 12px;
    }
    .editor-reset-btn:hover {
      background: var(--warning);
      color: var(--bg);
      border-color: var(--warning);
    }
    /* highlight selected table row in the editor */
    .selected-row td {
      background: color-mix(in srgb, Field 75%, var(--accent) 25%) !important;
    }

    /*
      Modal actions bar: ensures that the Speichern/Abbruch buttons in the
      Editor remain visible even when the dialog content is scrolled. The bar
      sticks to the bottom of the scrollable modal and uses the same
      colouring as the panel. It also adds a top border to visually
      separate it from the content. The high z-index prevents it from
      being overlapped by table content inside the editor.
    */
    .modal-actions {
      position: sticky;
      bottom: 0;
      background: var(--panel);
      padding: 8px 0;
      display: flex;
      gap: 10px;
      justify-content: flex-end;
      border-top: 1px solid var(--border);
      z-index: 10;
    }

    /*
      Colour picker for the rich text editor. Each picker displays a row
      of small coloured squares instead of a select dropdown. Hovering a
      colour square outlines it with the accent colour. The picker itself
      uses a flex layout to minimise spacing between items, contributing to
      a more compact toolbar.
    */
    .color-picker {
      display: inline-flex;
      align-items: center;
      gap: 2px;
    }
    .color-picker button {
      width: 18px;
      height: 18px;
      border: 1px solid var(--border);
      border-radius: 3px;
      cursor: pointer;
      padding: 0;
    }
    .color-picker button:hover {
      outline: 2px solid var(--accent);
      outline-offset: 1px;
    }
    /* Reduce spacing in the floating RTE toolbar for a compact look */
    .rte-float .rte-toolbar {
      gap: 2px;
    }
    .rte-float .rte-toolbar button {
      padding: 2px 6px;
    }
</style>
<!-- Tabellen-Stile f√ºr Richtext-Kommentare und Editor -->
<style>
.richbox table,
.comment-body table {
  border-collapse: collapse;
  width: 100%;
  margin: 0.5em 0;
  min-width: 0;
}
.richbox th, .richbox td,
.comment-body th, .comment-body td {
  border: 1px solid var(--border);
  padding: 4px 6px;
  background: var(--surface);
  color: var(--text);
}
.richbox th, .comment-body th {
  background: var(--panel);
  font-weight: 600;
}
#qtext {
    background: var(--panel);
    padding: 8px;
    border-radius: 6px;
    min-height: 100px; /* optional */
    color: var(--text);
}
</style>
</head>
<body>
<div id="main">
  <div class="dashboard-header">
    <h2>üìä Quiz Dashboard</h2>
    <div>
      <!-- Primary actions on the dashboard are given the "header-big-btn" class for prominence -->
      <button type="button" onclick="showQuizInit()" class="header-big-btn">Start Quiz</button>
      <button type="button" onclick="showEditor()" class="header-big-btn">Question Database</button>
      <!-- Secondary actions use smaller buttons with dark backgrounds; their hover states signal caution/danger -->
      <button type="button" onclick="resetCache()" class="header-small-reset-btn">üîÑ Reset quiz settings</button>
      <button type="button" onclick="resetAllData()" class="header-small-delete-btn">üóëÔ∏è Delete all quiz data</button>
    </div>
  </div>

  <div class="settings-panel">
    <div class="input-group">
      <label for="target-repetitions">Repetitions until the question is learned:</label>
      <input type="number" id="target-repetitions" min="1" max="20" value="3" onchange="updateDashboard()">
    </div>
    <div class="input-group">
      <label for="start-date">Start date:</label>
      <input type="date" id="start-date" onchange="updateDashboard()">
    </div>
    <div class="input-group">
      <label for="exam-date">End date:</label>
      <input type="date" id="exam-date" onchange="updateDashboard()">
    </div>
    <div class="input-group">
      <button type="button" onclick="saveDashboardSettings()" style="margin-top: 28px;">Save settings</button>
    </div>
  </div>

  <div class="dashboard-card">
    <h3>üìÖ Study plan</h3>
    <div id="planning-info"></div>
    <div class="chart-container">
      <canvas id="planning-chart"></canvas>
    </div>
  </div>

  <div class="dashboard-card" style="margin-top: 20px;">
    <h3>üéØ Progress by topic</h3>
    <div id="theme-progress"></div>
  </div>
</div>

<div id="editor" style="display:none;"></div>
<div id="importer" style="display:none;"></div>
<div id="quiz-card" style="display:none;"></div>
<div id="progress"></div>
<div id="edit-modal"><div id="modal-content"></div></div>
<div id="preview-modal"><div id="preview-content"></div></div>

<!-- Native Browser-Dialog -->
<div class="native-dialog-overlay" id="dialog-overlay"></div>
<div class="native-dialog" id="native-dialog">
  <h4 id="dialog-title">Notice</h4>
  <p id="dialog-message"></p>
  <div class="native-dialog-buttons">
    <button type="button" id="dialog-cancel" style="display:none;">Cancel</button>
    <button type="button" id="dialog-ok">OK</button>
  </div>
</div>

<script>
/* ========= Globale Variablen ========= */
const dbKey = 'quizdb_v2';
const settingsKey = 'quiz_settings';
let questions = [];
let quizIdx = 0, quizList = [], quizProg = 0, current = null, quizAnsOrder = [];
let overallChart = null, planningChart = null;
let quizCheckedOnce = false; // mehrfaches Pr√ºfen verhindern
// Editor-Suche (persistiert w√§hrend der Session)
let editorSearch = { nr: '', text: '', date: '' };
// Speichert die zuletzt ausgew√§hlte Zeile in der Fragen-Datenbank. Dieser Wert
// bestimmt, welche Zeile dauerhaft markiert bleibt, bis der Benutzer eine
// andere ausw√§hlt oder den Editor verl√§sst.
let editorSelectedRowId = null;
// Quiz-Suche (persistiert w√§hrend der Session)
// Speichert den Suchtext f√ºr das Quiz-Startfenster. Der Wert wird im Suchfeld
// vorbef√ºllt und erst durch Klick auf das ‚úï-Symbol oder ESC gel√∂scht.
let quizSearch = { text: '' };

/* ====== Dataset-Info ======
 *
 * Um im Fortschrittsbalken zus√§tzliche Metainformationen zur aktuell
 * geladenen Fragensammlung anzuzeigen, werden Name, Versionsnummer und
 * das Datum der letzten √Ñnderung zentral gespeichert. Diese Daten
 * werden im localStorage unter "quiz_datasetInfo" persistiert und beim
 * Laden der Seite wiederhergestellt. Beim Import aus einer Datei
 * aktualisieren wir diese Felder automatisch anhand des Dateinamens
 * (Versionserkennung √ºber den letzten Unterstrich) und des
 * Dateizeitstempels. Bei Bedarf kann updateDatasetInfo() manuell
 * aufgerufen werden, um neue Werte zu setzen.
 */
let datasetName = '';
let datasetVersion = '';
let datasetLastModified = '';

function loadDatasetInfo() {
  try {
    const info = JSON.parse(localStorage.getItem('quiz_datasetInfo') || '{}');
    datasetName = info.name || '';
    datasetVersion = info.version || '';
    datasetLastModified = info.lastModified || '';
  } catch(e) {
    datasetName = '';
    datasetVersion = '';
    datasetLastModified = '';
  }
}

function updateDatasetInfo(name, version, lastModified) {
  datasetName = name || '';
  datasetVersion = version || '';
  datasetLastModified = lastModified || '';
  localStorage.setItem('quiz_datasetInfo', JSON.stringify({ name: datasetName, version: datasetVersion, lastModified: datasetLastModified }));
}

// Beim Start die gespeicherten Metadaten laden
loadDatasetInfo();

// Falls keine Datensatzinformationen vorhanden sind (z.B. bei lokal ge√∂ffneter HTML‚ÄëDatei),
// initialisiere sie mit dem aktuellen Dateinamen und dem bekannten √Ñnderungsdatum.  So wird
// der Dateiname (KI_Quiz_dark_final.html) und das zuletzt ge√§nderte Datum (04.10.2025)
// immer im Fortschrittsbereich angezeigt.  Sollte sp√§ter ein anderes Dataset importiert
// werden, setzt updateDatasetInfo() diese Werte entsprechend.
if (!datasetName) {
  updateDatasetInfo('KI_Quiz_dark_final.html', '', '04.10.2025');
}


/* ========= Hilfsfunktionen ========= */
function generateId(){ return Math.random().toString(36).slice(2) + Date.now().toString(36); }
function getActualPercentSnapshot(target){
  const t = Math.max(1, target || 1);
  const total = questions.length;
  if (!total) return 0;
  const sum = questions.reduce((s,q)=> s + Math.min((q.progress||0)/t, 1), 0);
  return (sum/total)*100;
}
function getLearnedPercentSnapshot(target){
  const t = Math.max(1, target || 1);
  const total = questions.length;
  if (!total) return 0;
  const learned = questions.filter(q => (q.progress||0) >= t).length;
  return (learned/total)*100;
}

/** Datumsformatierung lokal YYYY-MM-DD (ohne TZ-Shift) */
function fmtYMD(d) {
  const y = d.getFullYear();
  const m = String(d.getMonth()+1).padStart(2,'0');
  const day = String(d.getDate()).padStart(2,'0');
  return `${y}-${m}-${day}`;
}
/** Sicheres Parsen von "YYYY-MM-DD" als lokales Datum */
function parseYMD(s) {
  const [y,m,d] = (s||'').split('-').map(Number);
  return new Date(y, (m||1)-1, d||1);
}

/** Excel-Seriennummer ‚Üí Date (lokal) */
function dateFromExcelSerial(n){
  // Excel epoch 1899-12-30
  const ms = (n - 25569) * 86400 * 1000;
  return new Date(ms);
}

/** Flexibles Datums-Parsing, gibt ISO-String (yyyy-mm-ddTHH:MM:SSZ) zur√ºck oder null */
function parseToISO(val){
  if (val == null || val === '') return null;

  // Bereits Date?
  if (Object.prototype.toString.call(val) === '[object Date]') {
    return isNaN(val.getTime()) ? null : val.toISOString();
  }

  // Excel-Seriennummer (Zahl)
  if (typeof val === 'number' && isFinite(val)) {
    const d = dateFromExcelSerial(val);
    if (!isNaN(d)) return d.toISOString();
  }

  // String-Parsing
  const s = String(val).trim();

  // ISO direkt
  const isoTry = new Date(s);
  if (!isNaN(isoTry)) return isoTry.toISOString();

  // dd.mm.yyyy oder d.m.yyyy
  let m = s.match(/^(\d{1,2})[.\-/](\d{1,2})[.\-/](\d{2,4})$/);
  if (m){
    let dd = parseInt(m[1],10), mm = parseInt(m[2],10), yyyy = parseInt(m[3],10);
    if (yyyy < 100) yyyy += 2000; // zweistelliges Jahr
    const d = new Date(yyyy, mm-1, dd, 12); // 12:00 verhindert TZ-Verschiebung beim ISO-Export
    return isNaN(d) ? null : d.toISOString();
  }

  // yyyy.mm.dd
  m = s.match(/^(\d{4})[.\-/](\d{1,2})[.\-/](\d{1,2})$/);
  if (m){
    const yyyy = parseInt(m[1],10), mm = parseInt(m[2],10), dd = parseInt(m[3],10);
    const d = new Date(yyyy, mm-1, dd, 12);
    return isNaN(d) ? null : d.toISOString();
  }

  return null;
}

/* ========= Einstellungen laden/speichern ========= */
function loadDashboardSettings() {
  const defaults = {
    targetRepetitions: 3,
    startDate: new Date().toISOString().split('T')[0],
    examDate: new Date(Date.now() + 30*24*60*60*1000).toISOString().split('T')[0]
  };
  const settings = JSON.parse(localStorage.getItem(settingsKey) || JSON.stringify(defaults));

  const targetReps = document.getElementById('target-repetitions');
  const startDate  = document.getElementById('start-date');
  const examDate   = document.getElementById('exam-date');

  if(targetReps) targetReps.value = settings.targetRepetitions;
  if(startDate)  startDate.value  = settings.startDate;
  if(examDate)   examDate.value   = settings.examDate;

  return settings;
}

function saveDashboardSettings() {
  const targetRepsEl = document.getElementById('target-repetitions');
  const startDateEl  = document.getElementById('start-date');
  const examDateEl   = document.getElementById('exam-date');
  if(!targetRepsEl || !startDateEl || !examDateEl){ console.error("Dashboard Eingabefelder nicht gefunden"); return; }

  const settings = {
    targetRepetitions: parseInt(targetRepsEl.value),
    startDate: startDateEl.value,
    examDate:  examDateEl.value
  };
  localStorage.setItem(settingsKey, JSON.stringify(settings));
  updateDashboard();
  showNativeDialog('Settings have been saved!', 'Saved');
}

/* ========= Native Dialoge ========= */
function showNativeDialog(message, title = 'Notice', showCancel = false) {
  return new Promise((resolve) => {
    document.getElementById('dialog-title').textContent = title;
    document.getElementById('dialog-message').textContent = message;
    document.getElementById('dialog-cancel').style.display = showCancel ? 'inline-block' : 'none';
    document.getElementById('dialog-overlay').style.display = 'block';
    document.getElementById('native-dialog').style.display = 'block';

    const handleOk = () => { cleanup(); resolve(true); };
    const handleCancel = () => { cleanup(); resolve(false); };
    const cleanup = () => {
      document.getElementById('dialog-overlay').style.display = 'none';
      document.getElementById('native-dialog').style.display = 'none';
      document.getElementById('dialog-ok').removeEventListener('click', handleOk);
      document.getElementById('dialog-cancel').removeEventListener('click', handleCancel);
    };
    document.getElementById('dialog-ok').addEventListener('click', handleOk);
    if (showCancel) document.getElementById('dialog-cancel').addEventListener('click', handleCancel);
  });
}
window.alert  = (message) => showNativeDialog(message, 'Notice', false);
window.confirm= (message) => showNativeDialog(message, 'Confirmation', true);

/* ========= Datenbank laden/speichern ========= */
function ensureIds(){
  // sorge daf√ºr, dass jede Frage eine stabile id & history hat
  questions.forEach(q => {
    if (!q.id) q.id = generateId();
    if (!Array.isArray(q.history)) q.history = [];
  });
}
function loadQuestions() {
  questions = JSON.parse(localStorage.getItem(dbKey) || '[]');
  ensureIds();
}
function saveQuestions() {
  localStorage.setItem(dbKey, JSON.stringify(questions));
  if (document.getElementById('target-repetitions')) updateDashboard();
}
// dd.mm.yyyy / d.m.yy / ISO / Excel-Serienzahl robust parsen
function parseFlexibleDate(val){
  if (!val && val !== 0) return null;

  // Schon Date?
  if (val instanceof Date && !isNaN(val)) return val;

  // Excel Serienzahl (z.B. 45924)
  if (typeof val === 'number' && isFinite(val)) {
    // Excel-Nullpunkt: 1899-12-30 (inkl. 1900-Leap-Bug-Korrektur)
    const excelEpoch = Date.UTC(1899, 11, 30);
    const ms = Math.round(val * 86400000);
    return new Date(excelEpoch + ms);
  }

  if (typeof val === 'string') {
    const s = val.trim();

    // dd.mm.yyyy | d.m.yyyy | dd-mm-yyyy | dd/mm/yyyy
    const m = s.match(/^(\d{1,2})[.\-\/](\d{1,2})[.\-\/](\d{2,4})$/);
    if (m){
      const d = parseInt(m[1],10);
      const mo = parseInt(m[2],10)-1;
      let y = m[3].length === 2 ? parseInt('20'+m[3],10) : parseInt(m[3],10);
      return new Date(y, mo, d);
    }

    // Fallback: Date.parse f√ºr ISO/englische Formate
    const t = Date.parse(s);
    if (!isNaN(t)) return new Date(t);
  }

  return null;
}

// Alle Datumsfelder in questions ‚Üí ISO (Tagesmitte, um TZ-Shifts zu vermeiden)
function normalizeAllDates(){
  let changed = false;
  questions.forEach(q=>{
    ['createdAt','updatedAt','lastAnswered'].forEach(k=>{
      if (q && q[k] !== undefined && q[k] !== null && q[k] !== '') {
        const d = parseFlexibleDate(q[k]);
        if (d && !isNaN(d)) {
          // 12:00 lokale Zeit ‚Üí ISO; vermeidet ‚ÄûVortag/Nachtag‚Äú-Spr√ºnge
          const norm = new Date(d.getFullYear(), d.getMonth(), d.getDate(), 12, 0, 0).toISOString();
          if (q[k] !== norm) { q[k] = norm; changed = true; }
        } else {
          // Ung√ºltig ‚Üí leeren statt kaputten Wert behalten
          q[k] = null;
          changed = true;
        }
      }
    });

    // History Feld sicherstellen
    if (!Array.isArray(q.history)) q.history = [];
  });
  if (changed) saveQuestions(); // triggert auch Dashboard/Charts-Refresh
}

/* ========= Dashboard ========= */
function updateDashboard(){
  const targetRepsEl = document.getElementById('target-repetitions');
  const startDateEl  = document.getElementById('start-date');
  const examDateEl   = document.getElementById('exam-date');

  if(!targetRepsEl || !startDateEl || !examDateEl){
    const saved = JSON.parse(localStorage.getItem(settingsKey) || '{}');
    const settings = {
      targetRepetitions: saved.targetRepetitions || 3,
      startDate: saved.startDate || new Date().toISOString().split('T')[0],
      examDate:  saved.examDate  || new Date(Date.now()+30*24*60*60*1000).toISOString().split('T')[0]
    };
    loadQuestions();
    normalizeAllDates(); // <‚Äî NEU: sorgt daf√ºr, dass die Charts g√ºltige ISO-Daten sehen

    return;
  }

  loadQuestions();
  const settings = {
    targetRepetitions: parseInt(targetRepsEl.value),
    startDate: startDateEl.value,
    examDate:  examDateEl.value
  };
  updatePlanningView(settings);
  updateThemeProgress(settings);
}
function buildConsistentHistory(q){
  const hist = Array.isArray(q.history) ? q.history.slice() : [];
  const total = Math.max(0, Number(q.progress) || 0);
  const have  = hist.reduce((s,e)=> s + (Number(e.delta)||0), 0);

  if (have < total) {
    const ts = (q.lastAnswered || q.updatedAt || q.createdAt || new Date().toISOString());
    for (let k = 0; k < (total - have); k++) hist.push({ ts, delta: 1 });
  }
  return hist;
}

/* Tagesverlauf 0..100% (anteilig bis Ziel-Wiederholungen) */
function calculateDailyProgressPercent(questions, maxRepetitions) {
  const normalized = (questions || []).map(q => {
  const qq = { ...q };
  qq.history = buildConsistentHistory(qq); // <- immer konsistente History nutzen
  return qq;
});



  const hasAnyEvent = normalized.some(q => (q.history || []).length > 0);
  if (!normalized.length || !hasAnyEvent) return [];

  let minTs = null, maxTs = null;
  normalized.forEach(q => (q.history || []).forEach(ev => {
    const t = new Date(ev.ts);
    if (!isFinite(t)) return;
    if (!minTs || t < minTs) minTs = t;
    if (!maxTs || t > maxTs) maxTs = t;
  }));
  if (!minTs) minTs = new Date();
  if (!maxTs) maxTs = new Date();

  const days = [];
  for (let d = new Date(minTs.getFullYear(), minTs.getMonth(), minTs.getDate());
       d <= maxTs; d = new Date(d.getTime() + 24*60*60*1000)) {
    days.push(fmtYMD(d));
  }

  const totalQuestions = normalized.length;
  const perQuestionDaily = normalized.map(q => {
    const map = {};
    (q.history || []).forEach(ev => {
      const day = fmtYMD(new Date(ev.ts));
      map[day] = (map[day] || 0) + (Number(ev.delta) || 0);
    });
    return map;
  });

  const cumPerQuestion = normalized.map(() => 0);
  const out = [];
  days.forEach(day => {
    perQuestionDaily.forEach((m, i) => { if (m[day]) cumPerQuestion[i] += m[day]; });
    const avgFraction = cumPerQuestion.reduce((s, c) => s + Math.min(c / Math.max(1, maxRepetitions), 1), 0) / totalQuestions;
    out.push({ date: day, progress: Math.min(100, Math.max(0, avgFraction * 100)) });
  });
  return out;
}
/* Ermittelt pro Frage das Datum, an dem sie "gelernt" wurde (>= Ziel-Wiederholungen).
   Gibt eine aufsteigend sortierte Liste von ISO-Daten (YYYY-MM-DD) zur√ºck. */
function getLearnedDatesSorted(questions, maxRepetitions){
  const T = Math.max(1, maxRepetitions || 1);
  const dates = [];
  (questions || []).forEach(q => {
    const progress = Number(q.progress) || 0;
    let learnedDate = null;

    if (Array.isArray(q.history) && q.history.length){
      // aus History ableiten
      let cum = 0;
      const hist = q.history.slice().sort((a,b)=> new Date(a.ts) - new Date(b.ts));
      for (const ev of hist){
        cum += Number(ev.delta) || 0;
        if (cum >= T){ learnedDate = new Date(ev.ts); break; }
      }
    } else if (progress >= T){
      // Fallback ohne History
      learnedDate = q.lastAnswered ? new Date(q.lastAnswered)
                : q.updatedAt    ? new Date(q.updatedAt)
                : q.createdAt    ? new Date(q.createdAt)
                : null;
    }

    if (learnedDate && isFinite(learnedDate)) {
      dates.push(fmtYMD(learnedDate)); // YYYY-MM-DD
    }
  });
  dates.sort(); // lexikographisch richtig
  return dates;
}

/* Prozent der ‚Äûgelernten‚Äú Fragen (>= Ziel-Wdh) pro Tag ‚Äì robust auch ohne History */
function calculateDailyLearnedPercent(questions, maxRepetitions) {
  const T = Math.max(1, maxRepetitions || 1);
  const qs = (questions || []).map(q => {
    const qq = { ...q };
    qq.history = buildConsistentHistory(qq);
    return qq;
  });

  const total = qs.length;
  if (!total) return [];

  const learnedOnISO = [];
  let minStart = null;

  qs.forEach(q => {
    // minStart bestimmen
    if (q.createdAt) {
      const cd = new Date(q.createdAt);
      if (isFinite(cd)) minStart = !minStart || cd < minStart ? cd : minStart;
    }
    (q.history || []).forEach(ev => {
      const d = new Date(ev.ts);
      if (isFinite(d)) minStart = !minStart || d < minStart ? d : minStart;
    });

    // gelernt-am Datum aus (jetzt konsistenter) History
    let cum = 0, learnedDate = null;
    const hist = (q.history || []).slice().sort((a,b) => new Date(a.ts) - new Date(b.ts));
    for (const ev of hist){
      cum += Number(ev.delta) || 0;
      if (cum >= T) { learnedDate = new Date(ev.ts); break; }
    }

    // Fallback (sollte selten n√∂tig sein)
    if (!learnedDate && (q.progress || 0) >= T) {
      learnedDate = q.lastAnswered ? new Date(q.lastAnswered)
                  : q.updatedAt    ? new Date(q.updatedAt)
                  : q.createdAt    ? new Date(q.createdAt)
                  : null;
    }
    if (learnedDate && isFinite(learnedDate)) learnedOnISO.push(fmtYMD(learnedDate));
  });

  // Tagesreihe kumulativ 0..Heute
  const DAY = 86400000;
  const start = minStart
    ? new Date(minStart.getFullYear(), minStart.getMonth(), minStart.getDate())
    : new Date();
  const end = new Date();

  learnedOnISO.sort();
  let acc = 0, j = 0;
  const out = [];
  for (let d = new Date(start); d <= end; d = new Date(d.getTime() + DAY)) {
    const iso = fmtYMD(d);
    while (j < learnedOnISO.length && learnedOnISO[j] <= iso) { acc++; j++; }
    out.push({ date: iso, progress: (acc / total) * 100 });
  }
  return out;
}




/* Planung/Statistik */
function updatePlanningView(settings) {
  const planningInfoEl = document.getElementById('planning-info');
  if (!planningInfoEl) return;
  const totalQuestions = questions.length;

  const learnedQuestions = questions.filter(q => (q.progress || 0) >= settings.targetRepetitions).length;

  const todayStr = new Date().toDateString();
  const answeredToday = questions.filter(q => q.lastAnswered && new Date(q.lastAnswered).toDateString() === todayStr).length;

  const startDate = new Date(settings.startDate);
  const examDate  = new Date(settings.examDate);
  const today     = new Date();

 const DAY = 24 * 60 * 60 * 1000;
 const s0 = new Date(startDate.getFullYear(), startDate.getMonth(), startDate.getDate());
 const e0 = new Date(examDate.getFullYear(), examDate.getMonth(), examDate.getDate());
 const t0 = new Date(today.getFullYear(), today.getMonth(), today.getDate());

 const totalDays    = Math.max(1, Math.round((e0 - s0) / DAY));
 const daysPassed   = Math.min(totalDays, Math.max(0, Math.floor((t0 - s0) / DAY)));
 const daysRemaining= Math.max(0, Math.floor((e0 - t0) / DAY));
 const plannedProgress = (daysPassed / totalDays) * 100;

  const target = settings.targetRepetitions;
  const actualProgress = totalQuestions > 0
    ? questions.reduce((sum, q) => sum + Math.min((q.progress || 0) / target, 1), 0) / totalQuestions * 100
    : 0;

  planningInfoEl.innerHTML = `
    <div class="stats-grid">
      <div class="stat-item"><div class="stat-value">${totalQuestions}</div><div class="stat-label">Total questions</div></div>
      <div class="stat-item"><div class="stat-value">${learnedQuestions}</div><div class="stat-label">Questions learned</div></div>
      <div class="stat-item"><div class="stat-value">${answeredToday}</div><div class="stat-label">Answered today</div></div>
      <div class="stat-item"><div class="stat-value">${daysRemaining}</div><div class="stat-label">Days remaining</div></div>
    </div>
    <div style="margin:16px 0;">
      <div>Learning progress with all repetitions vs. planned</div>
      <div class="progress-bar">
        <div class="progress-fill ${actualProgress >= plannedProgress ? 'good' : actualProgress >= plannedProgress * 0.8 ? 'warning' : 'danger'}"
          style="width:${Math.max(actualProgress, 2)}%"></div>
      </div>
      <div style="font-size: 0.9em; margin-top: 4px;">
        Actual: ${Math.round(actualProgress)}% | Target: ${Math.round(plannedProgress)}%
      </div>
    </div>
  `;

  updatePlanningChart(settings);
}
// === Plugin: vertikale "Heute"-Linie =========================================
(function(){
  if (!window._todayLineRegistered) {
    const todayLinePlugin = {
      id: 'todayLine',
      afterDatasetsDraw(chart, args, opts) {
        const xScale = chart.scales.x;
        const ca = chart.chartArea;
        if (!xScale || !ca) return;

        const idx = (opts && Number.isFinite(opts.index)) ? opts.index : -1;
        if (idx < 0 || idx >= (xScale.ticks?.length ?? 0)) return;

        // Pixel-Position des heutigen Ticks
        const x = xScale.getPixelForValue(chart.data.labels[idx]);

        const ctx = chart.ctx;
        const color = (opts && opts.color) || '#ef4444';
        const dash  = (opts && opts.dash)  || [4,4];
        const label = (opts && opts.label) || 'Today';

        ctx.save();
        ctx.setLineDash(dash);
        ctx.strokeStyle = color;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(x, ca.top);
        ctx.lineTo(x, ca.bottom);
        ctx.stroke();

        // Label innerhalb der Chart-Area
        ctx.setLineDash([]);
        ctx.fillStyle = color;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        ctx.font = '12px system-ui, sans-serif';
        ctx.fillText(label, x, ca.top + 4);
        ctx.restore();
      }
    };
    Chart.register(todayLinePlugin);
    window._todayLineRegistered = true;
  }
})();

/* Chart: Planung / Ist / Gelernte Fragen */
/* Chart: Planung / Ist / Gelernte Fragen (Ist-Linien unabh√§ngig von Start/Ende) */
/* Chart: Planung / Ist / Gelernte Fragen ‚Äî Anzeige nur Start..Ende ¬±2 Tage */
function updatePlanningChart(settings) {
  const canvas = document.getElementById('planning-chart');
  if (!canvas) return;
  const ctx = canvas.getContext('2d');
  if (window.planningChart) window.planningChart.destroy();

  const DAY = 24*60*60*1000;
  const start = parseYMD(settings.startDate);
  const end   = parseYMD(settings.examDate);

  // Wenn Zeitraum ung√ºltig: leeres Chart
  if (!isFinite(+start) || !isFinite(+end) || start > end) {
    window.planningChart = new Chart(ctx, { type:'line', data:{labels:[],datasets:[]}, options:{responsive:true,maintainAspectRatio:false} });
    return;
  }

  // Anzeige-Fenster = gew√§hlter Zeitraum ¬± 1Tage
  const padStart = new Date(start.getFullYear(), start.getMonth(), start.getDate() - 1);
  const padEnd   = new Date(end.getFullYear(),   end.getMonth(),   end.getDate()   + 1);

  // Ziel-Wiederholungen
  const targetReps = parseInt(document.getElementById('target-repetitions').value) || 3;

  // Tagesgenaue Reihen aus History (global berechnet, unabh√§ngig vom Zeitraum)
  const dailyProgressData = calculateDailyProgressPercent(questions, targetReps); // 0..100 kumulativ (alle Wdh. anteilig)
  const dailyLearnedData  = calculateDailyLearnedPercent(questions, targetReps);  // 0..100 kumulativ (Anteil gelernter Fragen)

  const histMap    = new Map(dailyProgressData.map(d => [d.date, d.progress]));
  const learnedMap = new Map(dailyLearnedData.map(d => [d.date, d.progress]));

  // Helper: Wert bis zu einem Stichtag (Carry-In) finden
  const carryFromArr = (arr, isoCut) => {
    let last = null;
    for (let i = 0; i < arr.length; i++) {
      const di = arr[i];
      if (di.date <= isoCut) last = di.progress;
      else break; // Arrays sind chronologisch, da wir sie erzeugt haben
    }
    return last;
  };

  // X-Achse f√ºr das Anzeige-Fenster
  const labelsISO = [];
  for (let d = new Date(padStart.getFullYear(), padStart.getMonth(), padStart.getDate());
       d <= padEnd; d = new Date(d.getTime() + DAY)) {
    labelsISO.push(fmtYMD(d));
  }
  const labels = labelsISO.map(iso => parseYMD(iso).toLocaleDateString('en-GB', { day:'2-digit', month:'2-digit' }));
  const todayISO = fmtYMD(new Date());
  const todayIdx = labelsISO.indexOf(todayISO);  // -1, wenn heute nicht im Fenster liegt

  // Planung linear 0..100 nur innerhalb Start..Ende; au√üerhalb null (kein Render)
  const s0 = new Date(start.getFullYear(), start.getMonth(), start.getDate());
  const e0 = new Date(end.getFullYear(), end.getMonth(), end.getDate());
  const totalDays = Math.max(1, Math.round((e0 - s0) / DAY));
  
  const plannedData = labelsISO.map(iso => {
    const cur = parseYMD(iso);
    if (cur < s0 || cur > e0) return null;
    const i = Math.floor((cur - s0) / DAY); // identisch zur Kachel
    return Math.min(100, (i / totalDays) * 100);
  });


  // Ist-Linien: Carry-In zum Fensteranfang, danach tagesweise fortschreiben
  const todayYMD = fmtYMD(new Date());

  let lastKnownAbs = carryFromArr(dailyProgressData, labelsISO[0]);   // kann null sein
  const actualAbsData = labelsISO.map(iso => {
    if (histMap.has(iso)) lastKnownAbs = histMap.get(iso);
    // Optional: wenn du nach "heute" nicht weiter zeichnen willst, verwende:
    if (iso > todayYMD) return null;
    return lastKnownAbs;
  });
  
  let lastKnownLearned = carryFromArr(dailyLearnedData, labelsISO[0]); // kann null sein
  const learnedData = labelsISO.map(iso => {
    if (learnedMap.has(iso)) lastKnownLearned = learnedMap.get(iso);
    if (iso > todayYMD) return null;
    return lastKnownLearned; // in der Zukunft flach weiterzeichnen
  });


  // Render
  window.planningChart = new Chart(ctx, {
    type: 'line',
    data: {
      labels,
      datasets: [
        {
          label:'Planned',
          data: plannedData,
          borderColor:'#3b82f6',
          backgroundColor:'rgba(59,130,246,0.1)',
          tension:0.0,
          pointRadius:0,
          spanGaps:false
        },
        {
          label:'Actual progress (absolute)',
          data: actualAbsData,
          borderColor:'#22c55e',
          backgroundColor:'rgba(34,197,94,0.1)',
          tension:0.0,
          pointRadius:0,
          spanGaps:false
        },
        {
          label:'Questions learned (proportion)',
          data: learnedData,
          borderColor:'#a855f7',
          backgroundColor:'rgba(168,85,247,0.12)',
          tension:0.0,
          pointRadius:0,
          spanGaps:false,
          borderDash:[6,3]
        },
      ],
    },
    options: {
      responsive:true,
      maintainAspectRatio:false,
      interaction:{ mode:'index', intersect:false },
      plugins:{
        tooltip:{ callbacks:{ label:(ctx)=> (ctx.raw==null?'':`${ctx.dataset.label}: ${Math.round(ctx.parsed.y)}%`) } },
        zoom:{ pan:{enabled:true,mode:'x'}, zoom:{wheel:{enabled:true}, pinch:{enabled:true}, mode:'x'}, limits:{x:{minRange:3}} },
        todayLine: { index: todayIdx, label: 'Today', color: '#ef4444', dash: [4,4] } // <‚Äî NEU
      },
      scales:{ y:{ beginAtZero:true, max:100, ticks:{ callback:v=>v+'%' } } }
    },
  });

  canvas.addEventListener('dblclick', () =>
    window.planningChart.resetZoom && window.planningChart.resetZoom(),
    { passive:true }
  );
}





/* Themen-Fortschritt */
function updateThemeProgress(settings) {
  const themeProgressEl = document.getElementById('theme-progress');
  if (!themeProgressEl) return;

  const themes = [...new Set(questions.map(q => q.topic).filter(Boolean))];
  if (themes.length === 0) {
    themeProgressEl.innerHTML = '<p style="text-align: center; opacity: 0.7;">No topics available. Add questions to track progress.</p>';
    return;
  }

  const target = parseInt(document.getElementById('target-repetitions').value) || 3;
  const themeHtml = themes.map(theme => {
    const themeQuestions = questions.filter(q => q.topic === theme);
    const percentage = themeQuestions.length > 0
      ? themeQuestions.reduce((sum, q) => sum + Math.min((q.progress || 0) / target, 1), 0) / themeQuestions.length * 100
      : 0;

    const learned = themeQuestions.filter(q => (q.progress || 0) >= target).length;
    const avgProgress = themeQuestions.length > 0 ? themeQuestions.reduce((s, q) => s + (q.progress || 0), 0) / themeQuestions.length : 0;

    let progressClass = 'good';
    if (percentage < 50) progressClass = 'danger';
    else if (percentage < 80) progressClass = 'warning';

    return `
      <div class="theme-progress">
        <div class="theme-header">
          <div class="theme-name">${theme}</div>
          <div class="theme-stats">${learned}/${themeQuestions.length} questions learned (√ò ${avgProgress.toFixed(1)}x)</div>
        </div>
        <div class="progress-bar">
          <div class="progress-fill ${progressClass}" style="width: ${Math.max(percentage, 2)}%"></div>
        </div>
        <div style="font-size: 0.9em; margin-top: 4px; opacity: 0.8;">
          ${Math.round(percentage)}% repetitions completed
        </div>
      </div>
    `;
  }).join('');

  themeProgressEl.innerHTML = themeHtml;
}

/* Sichtbarkeit */
function showOnly(id) {
  ['main','editor','importer','quiz-card'].forEach(x=>document.getElementById(x).style.display='none');
  document.getElementById(id).style.display='';
  document.getElementById('progress').textContent = '';
  if(id === 'main') updateDashboard();
}
function hideAll(){
  // Beim Verlassen des Editors wird die Auswahl zur√ºckgesetzt. Damit wird
  // die Zeilenmarkierung nicht f√§lschlicherweise beim erneuten √ñffnen
  // wiederhergestellt.
  editorSelectedRowId = null;
  showOnly('main');
}

/* Utils */

function escapeHTML(str){ return (''+str).replace(/[<>&"]/g, t => ({'<':'&lt;','>':'&gt;','&':'&amp;','"':'&quot;'}[t])) }
function formatDateYYYYMMDD(date) {
  if (!(date instanceof Date) || isNaN(date)) return '';
  let y = date.getFullYear();
  let m = String(date.getMonth()+1).padStart(2,'0');
  let d = String(date.getDate()).padStart(2,'0');
  return `${y}-${m}-${d}`;
}
function setupEditorSearch(){
  const input = document.getElementById('editor-search');
  const clear = document.getElementById('editor-search-clear');
  const count = document.getElementById('editor-search-count');
  const rows  = Array.from(document.querySelectorAll('#editor tbody tr'));
  const total = rows.length;

  const apply = () => {
    const q = (input.value || '').trim().toLowerCase();
    let visible = 0;
    rows.forEach(r => {
      const hay = (r.getAttribute('data-haystack') || '');
      const show = !q || hay.includes(q);
      r.style.display = show ? '' : 'none';
      if (show) visible++;
    });
    count.textContent = q ? `Matches: ${visible} / ${total}` : `Total: ${total}`;
  };

  if (input){
    // Wenn der Suchtext ge√§ndert wird, speichern wir ihn in editorSearch.text
    input.addEventListener('input', () => {
      editorSearch.text = input.value;
      apply();
    });
    // Mit Escape kann der Suchtext gel√∂scht werden
    input.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        input.value = '';
        editorSearch.text = '';
        apply();
      }
    });
  }
  if (clear){
    // Per Klick auf das ‚úï-Symbol wird der Suchtext gel√∂scht und der Fokus bleibt auf dem Feld
    clear.addEventListener('click', () => {
      input.value='';
      editorSearch.text = '';
      input.focus();
      apply();
    });
  }
  apply(); // Initial z√§hlen
}
/* ===== Quiz-Suche ===== */
// Pr√ºft, ob eine Frage q den Suchbegriff enth√§lt (in Nummer, Thema oder Text).
function matchesQuizSearch(q, search){
  if (!search) return true;
  const hay = ((q.nr || '') + ' ' + (q.topic || '') + ' ' + (q.text || '')).toLowerCase();
  return hay.includes(search);
}

// Richtet die Suchleiste im Quiz-Startbildschirm ein. Speichert den Suchtext in
// quizSearch.text und z√§hlt die Treffer. Aktualisiert auch bei Themen-/
// Schwierigkeits√§nderungen.
function setupQuizSearch(){
  const input = document.getElementById('quiz-search');
  const clearBtn = document.getElementById('quiz-search-clear');
  const count = document.getElementById('quiz-search-count');
  const update = () => {
    quizSearch.text = input ? input.value : '';
    const topicSel = document.getElementById('qtopic');
    const difSel   = document.getElementById('qdifficulty');
    const topic = topicSel ? topicSel.value : '';
    const dif   = difSel ? difSel.value   : '';
    const search = (quizSearch.text || '').trim().toLowerCase();
    const filtered = questions.filter(q =>
      (!topic || q.topic === topic) &&
      (!dif   || q.difficulty === dif) &&
      (!search || matchesQuizSearch(q, search))
    );
    if (count){
      if (search){
        count.textContent = `Matches: ${filtered.length}`;
      } else {
        count.textContent = `Questions: ${filtered.length}`;
      }
    }
  };
  if (input){
    input.addEventListener('input', update);
    input.addEventListener('keydown', (e)=>{
      if (e.key === 'Escape'){
        input.value = '';
        quizSearch.text = '';
        update();
      }
    });
  }
  if (clearBtn){
    clearBtn.addEventListener('click', ()=>{
      if (input){
        input.value = '';
        quizSearch.text = '';
        input.focus();
        update();
      }
    });
  }
  // Bei √Ñnderung von Thema oder Schwierigkeit die Trefferzahl aktualisieren
  const topicSel = document.getElementById('qtopic');
  const difSel   = document.getElementById('qdifficulty');
  if (topicSel) topicSel.addEventListener('change', update);
  if (difSel)   difSel.addEventListener('change', update);
  update();
}
// --- Auswahl sichern/wiederherstellen ---
let _savedRange = null;
function saveSelection(){
  const sel = window.getSelection();
  if (sel && sel.rangeCount) _savedRange = sel.getRangeAt(0).cloneRange();
}
function restoreSelection(){
  if (!_activeEditable || !_savedRange) return;
  const sel = window.getSelection();
  sel.removeAllRanges();
  sel.addRange(_savedRange);
}


/* === Richtext: Sicherheit + Helpers === */
function sanitizeHTML(html){
  return DOMPurify.sanitize(String(html||''), {
    // Erlaubte Tags f√ºr pasten. Wir erweitern die Liste um Tabellenelemente,
    // damit kopierte Tabellen (z.‚ÄØB. aus Excel, Webseiten) eingef√ºgt werden k√∂nnen.
    ALLOWED_TAGS: [
      'b','i','u','s','em','strong','sub','sup','br',
      'p','div','span','ul','ol','li','a','img',
      'h1','h2','h3','h4','h5','h6',
      // Tabellen und Zellen
      'table','thead','tbody','tr','td','th'
    ],
    // Erlaubte Attribute. Neben den bisherigen Attributen erlauben wir
    // colspan/rowspan f√ºr Tabellenzellen.
    ALLOWED_ATTR: ['href','target','rel','style','src','alt','title','colspan','rowspan'],
    FORBID_TAGS: ['script','style']
  });
}
function renderHTML(html){ return sanitizeHTML(html); }
function stripHTML(html){
  const d = document.createElement('div'); d.innerHTML = sanitizeHTML(html);
  return d.textContent || d.innerText || '';
}
// Feste Farbpalette
const COLOR_PRESETS = [
  { label: 'Schwarz', value: '#000000' },
  { label: 'Grau',    value: '#808080' },
  { label: 'Wei√ü',    value: '#ffffff' },
  { label: 'Rot',     value: '#ff0000' },
  { label: 'Blau',    value: '#0000ff' },
  { label: 'Gr√ºn',    value: '#008000' },
  { label: 'Gelb',    value: '#ffff00' },
];

// Dropdown-Handler: type = 'foreColor' (Text) | 'hiliteColor' (Hintergrund)
function onRteColorSelect(type, selectEl){
  const val = selectEl?.value;
  if(!val) return;                  // Platzhalter ignorieren
  restoreSelection();
  _activeEditable?.focus();
  try { document.execCommand(type, false, val); }
  catch(e){
    if (type === 'hiliteColor') { try { document.execCommand('backColor', false, val); } catch{} }
    else { try { document.execCommand('foreColor', false, val); } catch{} }
  }
  // zur√ºck auf Platzhalter
  selectEl.selectedIndex = 0;
}

// Handler f√ºr Klicks auf die farbigen Kacheln der Farbpalette. Erh√§lt
// denselben Command wie der Dropdown (foreColor oder hiliteColor) und
// setzt die Auswahl direkt ohne Dropdown. Fallbacks f√ºr √§ltere
// Browser werden ebenfalls ber√ºcksichtigt.
function onRteColorButtonClick(type, color) {
  if (!color) return;
  restoreSelection();
  if (_activeEditable) _activeEditable.focus();
  try {
    document.execCommand(type, false, color);
  } catch (e) {
    // Manche Browser nutzen backColor statt hiliteColor
    if (type === 'hiliteColor') {
      try { document.execCommand('backColor', false, color); } catch {}
    } else {
      try { document.execCommand('foreColor', false, color); } catch {}
    }
  }
}

// Wandelt top-level <div> aus contenteditable in <p> um
function normalizeRichHTML(html) {
  let s = String(html || '');

  // Leere Zeilen <div><br></div> ‚Üí <p>&nbsp;</p>
  s = s.replace(/<div>\s*<br>\s*<\/div>/gi, '<p>&nbsp;</p>');
  // Normale Zeilen <div>‚Ä¶</div> ‚Üí <p>‚Ä¶</p>
  s = s.replace(/<div>/gi, '<p>').replace(/<\/div>/gi, '</p>');

  return s;
}
/* ===== Editor-Suche: Helpers ===== */
function sameDay(iso, targetDate){
  if (!iso || !targetDate) return false;
  const d = new Date(iso);
  if (!isFinite(+d)) return false;
  return d.getFullYear() === targetDate.getFullYear()
      && d.getMonth() === targetDate.getMonth()
      && d.getDate() === targetDate.getDate();
}

function filterQuestionsForEditor(list){
  const nrQ   = (editorSearch.nr   || '').trim();
  const textQ = (editorSearch.text || '').trim().toLowerCase();
  const dateQ = (editorSearch.date || '').trim(); // yyyy-mm-dd (input[type=date])

  let targetDate = null;
  if (dateQ) {
    const d = parseYMD(dateQ);
    if (isFinite(+d)) targetDate = d;
  }

  return list.filter(q => {
    let ok = true;

    if (nrQ) {
      ok = ok && String(q.nr ?? '').includes(nrQ);
    }

    if (textQ) {
      const hay = [
        stripHTML(q.text || '').toLowerCase(),
        String(q.topic || '').toLowerCase(),
      ].join(' ');
      ok = ok && hay.includes(textQ);
    }

    if (targetDate) {
      ok = ok && (
        sameDay(q.createdAt,    targetDate) ||
        sameDay(q.updatedAt,    targetDate) ||
        sameDay(q.lastAnswered, targetDate)
      );
    }

    return ok;
  });
}

function renderEditorSearchBar(){
  return `
    <div id="editor-searchbar" class="settings-panel" style="margin-top:12px; margin-bottom:12px;">
      <div class="input-group">
        <label>Search No.</label>
        <input type="text" id="search-nr" placeholder="z.B. 12" value="${escapeHTML(editorSearch.nr)}">
      </div>
      <div class="input-group">
        <label>Search question / topic</label>
        <input type="text" id="search-text" placeholder="Keyword..." value="${escapeHTML(editorSearch.text)}">
      </div>
      <div class="input-group">
        <label>Date (created / modified / last answered)</label>
        <input type="date" id="search-date" value="${editorSearch.date}">
      </div>
      <div class="input-group" style="align-self:end">
        <button type="button" id="search-clear">Zur√ºcksetzen</button>
      </div>
    </div>
  `;
}

function attachEditorSearchHandlers(){
  const nr   = document.getElementById('search-nr');
  const text = document.getElementById('search-text');
  const date = document.getElementById('search-date');
  const clr  = document.getElementById('search-clear');

  if (nr)   nr.addEventListener('input',  ()=>{ editorSearch.nr   = nr.value;   showEditor(); });
  if (text) text.addEventListener('input',()=>{ editorSearch.text = text.value; showEditor(); });
  if (date) date.addEventListener('change',()=>{ editorSearch.date = date.value; showEditor(); });
  if (clr)  clr.addEventListener('click', ()=>{ editorSearch = { nr:'', text:'', date:'' }; showEditor(); });
}

/* === Mini-Richtext-Editor (contenteditable) === */
let _activeEditable = null;
function applySpanStyle(styleStr){
  if(!_activeEditable) return;
  const sel = window.getSelection();
  if(!sel || sel.rangeCount === 0) return;

  const range = sel.getRangeAt(0);

  // Cursor steht au√üerhalb? Fokus zur√ºck ins aktive Feld
  if(!_activeEditable.contains(range.commonAncestorContainer)) {
    _activeEditable.focus();
  }

  if (range.collapsed){
    // Cursor: leeren, gestylten Span einf√ºgen und Cursor hineinsetzen
    const span = document.createElement('span');
    span.setAttribute('style', styleStr);
    span.appendChild(document.createTextNode('\u200B')); // zero-width space
    range.insertNode(span);

    sel.removeAllRanges();
    const r = document.createRange();
    r.setStart(span.firstChild, 1);
    r.collapse(true);
    sel.addRange(r);
  } else {
    // Auswahl: Inhalt wrappen
    const frag = range.cloneContents();
    const div = document.createElement('div');
    div.appendChild(frag);
    const wrapper = document.createElement('span');
    wrapper.setAttribute('style', styleStr);
    wrapper.innerHTML = div.innerHTML;
    document.execCommand('insertHTML', false, sanitizeHTML(wrapper.outerHTML));
  }
}
function onRteColor(type, hex){
  if(!hex) return;
  restoreSelection();           // <‚Äî wichtig
  _activeEditable.focus();
  try { document.execCommand(type, false, hex); }
  catch(e){
    if (type === 'hiliteColor') { try { document.execCommand('backColor', false, hex); } catch{} }
    else { try { document.execCommand('foreColor', false, hex); } catch{} }
  }
}


function onRteFontChange(val){
  if(!val) return;
  restoreSelection();           // <‚Äî wichtig
  _activeEditable.focus();
  applySpanStyle(val === 'inherit' ? 'font-family: inherit;' : 'font-family: ' + val + ';');
  const s = document.getElementById('rte-font'); if (s) s.selectedIndex = 0;
}

function onRteSizeChange(val){
  if(!val) return;
  restoreSelection();           // <‚Äî wichtig
  _activeEditable.focus();
  applySpanStyle(val === 'inherit' ? 'font-size: inherit;' : 'font-size: ' + val + '; line-height: 1.4;');
  const s = document.getElementById('rte-size'); if (s) s.selectedIndex = 0;
}

function bindEditable(el){
  if(!el) return;
  el.setAttribute('contenteditable','true');
  el.classList.add('richbox');

  // === Responsive RTE behaviour ===
  // On larger screens (>768px) we keep the original behaviour: focusing or clicking
  // inside the editable area automatically shows the floating RTE. On small screens
  // (mobile view) the RTE can be summoned via a toggle button to save screen
  // real estate. We set up the toggle only once per editable element.
  if (window.innerWidth > 768) {
    // Beim ersten Fokussieren das RTE initialisieren und anzeigen.
    // Urspr√ºnglich wurde nur das focus‚ÄëEreignis verwendet. In der Praxis
    // kann der focus bei verschachtelten contenteditable‚ÄëElementen
    // (z.‚ÄØB. beim Klicken in ein bereits editierbares Feld) nicht mehr
    // ausgel√∂st werden. Deshalb erg√§nzen wir auch einen click‚ÄëListener.
    el.addEventListener('focus', ()=>{ initFloatingRte(); showRte(el); });
    // Auf jeden Mausklick innerhalb des Elements ebenfalls RTE einblenden.
    // So wird die Toolbox zuverl√§ssig angezeigt, auch wenn der native
    // focus nur auf ein Kind‚ÄëElement springt.
    el.addEventListener('click', ()=>{ initFloatingRte(); showRte(el); });
  } else {
    // On mobile, avoid auto‚Äëpopups. Instead, create a small toggle button
    // adjacent to the editable area to open the RTE on demand.
    if (!el.dataset.rteToggleAdded) {
      const toggleBtn = document.createElement('button');
      toggleBtn.type = 'button';
      toggleBtn.className = 'rte-toggle-btn';
      toggleBtn.title = 'Show toolbox';
      toggleBtn.textContent = 'üõ†Ô∏è';
      toggleBtn.addEventListener('click', (ev) => {
        ev.stopPropagation();
        initFloatingRte();
        showRte(el);
      });
      // Insert the toggle after the editable element
      el.parentNode.insertBefore(toggleBtn, el.nextSibling);
      // Flag so we don't add multiple toggles
      el.dataset.rteToggleAdded = 'true';
    }
    // On mobile, clicking inside the editable area should not auto‚Äëshow the RTE,
    // but we still track selection so that toolbar commands work correctly when
    // the RTE is manually opened.
    el.addEventListener('click', () => { _activeEditable = el; saveSelection(); });
    el.addEventListener('focus', () => { _activeEditable = el; saveSelection(); });
  }

  el.addEventListener('blur', ()=>{
    setTimeout(()=>{
      const f = document.getElementById('rte-float');
      const ae = document.activeElement;
      const clickedInToolbar = f && f.contains(ae);
      if (!clickedInToolbar) hideRte();
      ['keyup','mouseup'].forEach(evt =>
      el.addEventListener(evt, ()=>{ if(!_rteState.pinned) positionRte(el); }, {passive:true})
    );
    }, 0);
    
  });

  // --- NEU: HTML-Paste mit Sanitizing, Fallback auf Text ---
  el.addEventListener('paste', (e)=>{
    e.preventDefault();
    const dt    = e.clipboardData || window.clipboardData;
    const html  = dt && dt.getData ? dt.getData('text/html')  : '';
    const text  = dt && dt.getData ? dt.getData('text/plain') : '';

    if (html && html.trim()) {
      // h√§lt Formatierung (fett, kursiv, Listen, Links, ‚Ä¶) ‚Äì aber sicher
      document.execCommand('insertHTML', false, sanitizeHTML(html));
    } else if (text) {
      // Plaintext-Fallback: Zeilenumbr√ºche erhalten
      const safe = sanitizeHTML(text).replace(/\r?\n/g, '<br>');
      document.execCommand('insertHTML', false, safe);
    }
  });
['keyup','mouseup'].forEach(evt =>
  el.addEventListener(evt, ()=>{ if(!_rteState.pinned) positionRte(el); }, {passive:true})
);
}

function rteCmd(cmd, val){
  if(!_activeEditable) return;
  restoreSelection();           // <‚Äî wichtig
  _activeEditable.focus();
  document.execCommand(cmd, false, val || null);
}


function insertSymbol(sym){
  if(!_activeEditable || !sym) return;
  restoreSelection();           // <‚Äî wichtig
  _activeEditable.focus();
  document.execCommand('insertText', false, sym);
}

function insertImageFromFile(){
  if(!_activeEditable) return;
  const inp = document.createElement('input');
  inp.type='file'; inp.accept='image/*';
  inp.onchange=()=>{
    const f = inp.files && inp.files[0]; if(!f) return;
    const r = new FileReader();
    r.onload=()=>{ document.execCommand('insertImage', false, r.result); };
    r.readAsDataURL(f);
  };
  inp.click();
}

// F√ºgt eine Tabelle in das aktuelle Rich-Text-Feld ein. Fragt nach Zeilen-
// und Spaltenanzahl, beschr√§nkt auf maximal 10. Leere Zellen werden mit
// &nbsp; bef√ºllt, sodass sie sichtbar sind.
function insertTable(){
  if(!_activeEditable) return;
  let rows = parseInt(prompt('Number of rows:', '2'), 10);
  let cols = parseInt(prompt('Number of columns:', '2'), 10);
  if (!rows || rows < 1 || !cols || cols < 1) return;
  rows = Math.min(rows, 10);
  cols = Math.min(cols, 10);
  let html = '<table>';
  for (let r = 0; r < rows; r++){
    html += '<tr>';
    for (let c = 0; c < cols; c++){
      html += '<td>&nbsp;</td>';
    }
    html += '</tr>';
  }
  html += '</table>';
  restoreSelection();
  _activeEditable.focus();
  try {
    document.execCommand('insertHTML', false, html);
  } catch(e) {
    document.execCommand('insertHTML', false, html);
  }
}

// Bestimmt die aktuell ausgew√§hlte Tabellenzelle innerhalb eines
// contenteditable Rich‚ÄëText‚ÄëFeldes. Kehrt null zur√ºck, wenn kein
// Tabellenkontext vorliegt.
function getSelectedTableCell() {
  const sel = window.getSelection();
  if (!sel || sel.rangeCount === 0) return null;
  let node = sel.anchorNode;
  // Bei Textknoten auf die Elternzelle hochlaufen
  while (node && node.nodeType === 3) node = node.parentNode;
  while (node && node.tagName && node.tagName.toLowerCase() !== 'td' && node.tagName.toLowerCase() !== 'th') {
    node = node.parentNode;
  }
  return node || null;
}

// F√ºgt eine Zeile unterhalb der aktuellen Zeile ein. Ist keine Tabelle
// ausgew√§hlt, wird eine Fehlermeldung ausgegeben.
function addTableRow() {
  const cell = getSelectedTableCell();
  if (!cell) { alert('Place the cursor in a table cell to insert a row.'); return; }
  const row = cell.parentNode;
  const table = row.parentNode;
  const newRow = row.cloneNode(true);
  Array.from(newRow.cells).forEach(c => { c.innerHTML = '&nbsp;'; });
  row.parentNode.insertBefore(newRow, row.nextSibling);
}

// Entfernt die aktuelle Zeile, sofern mindestens eine weitere Zeile
// verbleibt. Bei Einzelzeilen erfolgt keine Aktion.
function removeTableRow() {
  const cell = getSelectedTableCell();
  if (!cell) { alert('Place the cursor in a table cell to delete a row.'); return; }
  const row = cell.parentNode;
  const table = row.parentNode;
  if (table.rows.length <= 1) return;
  row.parentNode.removeChild(row);
}

// F√ºgt eine Spalte rechts von der aktuellen Spalte ein. Ist keine
// Tabelle aktiv, erscheint eine Fehlermeldung.
function addTableColumn() {
  const cell = getSelectedTableCell();
  if (!cell) { alert('Place the cursor in a table cell to insert a column.'); return; }
  const colIndex = Array.from(cell.parentNode.children).indexOf(cell);
  const table = cell.closest('table');
  Array.from(table.rows).forEach(r => {
    const newCell = r.insertCell(colIndex + 1);
    newCell.innerHTML = '&nbsp;';
  });
}

// Entfernt die aktuelle Spalte, sofern mindestens eine weitere Spalte
// vorhanden ist.
function removeTableColumn() {
  const cell = getSelectedTableCell();
  if (!cell) { alert('Place the cursor in a table cell to delete a column.'); return; }
  const colIndex = Array.from(cell.parentNode.children).indexOf(cell);
  const table = cell.closest('table');
  if (!table || table.rows[0].cells.length <= 1) return;
  Array.from(table.rows).forEach(r => { r.deleteCell(colIndex); });
}

let _rteState = { pinned: false };
function saveRteBoxState(){
  const f = document.getElementById('rte-float');
  if (!f) return;

  // nicht speichern, wenn unsichtbar oder (noch) kollabiert
  const cs = getComputedStyle(f);
  if (cs.display === 'none') return;
  const w = f.offsetWidth, h = f.offsetHeight;
  if (w < 50 || h < 50) return;

  const pos = {
    left: parseInt(f.style.left) || f.offsetLeft || 12,
    top:  parseInt(f.style.top)  || f.offsetTop  || 12,
    width:  w,
    height: h,
    pinned: !!_rteState.pinned
  };
  localStorage.setItem('rte_pos', JSON.stringify(pos));
}


function initFloatingRte(){
  if (document.getElementById('rte-float')) return;

  const box = document.createElement('div');
  box.id = 'rte-float';
  box.className = 'rte-float';
  box.innerHTML = `
  <div class="rte-header" id="rte-handle">
    <span>‚úèÔ∏è Toolbox</span>
    <div class="right">
      <button type="button" id="rte-pin" class="pin" title="Position fixieren">üìå</button>
      <button type="button" id="rte-close" title="Schlie√üen">‚úñ</button>
    </div>
  </div>
  <div class="rte-toolbar">
    <!-- Erste Zeile: Standardformatierungen -->
    <button type="button" onclick="rteCmd('bold')"><b>B</b></button>
    <button type="button" onclick="rteCmd('italic')"><i>I</i></button>
    <button type="button" onclick="rteCmd('underline')"><u>U</u></button>
    <button type="button" onclick="rteCmd('strikeThrough')"><s>S</s></button>
    <button type="button" onclick="rteCmd('insertUnorderedList')">‚Ä¢ List</button>
    <button type="button" onclick="rteCmd('insertOrderedList')">1. List</button>
    <button type="button" onclick="rteCmd('justifyLeft')">‚ü∏</button>
    <button type="button" onclick="rteCmd('justifyCenter')">‚áî</button>
    <button type="button" onclick="rteCmd('justifyRight')">‚üπ</button>

    <select id="rte-font" title="Font" onchange="onRteFontChange(this.value)">
      <option value="">Font</option>
      <option value="inherit">Default</option>
      <option value="'Segoe UI', Roboto, Arial, sans-serif">System Sans</option>
      <option value="Arial, Helvetica, sans-serif">Arial</option>
      <option value="Georgia, 'Times New Roman', serif">Georgia/Times</option>
      <option value="'Times New Roman', Times, serif">Times New Roman</option>
      <option value="'Courier New', Courier, monospace">Courier New</option>
      <option value="Consolas, 'Courier New', monospace">Consolas</option>
      <option value="monospace">Monospace</option>
    </select>

    <select id="rte-size" title="Size" onchange="onRteSizeChange(this.value)">
      <option value="">Size</option>
      <option value="inherit">Default</option>
      <option value="12px">12</option><option value="14px">14</option>
      <option value="16px">16</option><option value="18px">18</option>
      <option value="20px">20</option><option value="24px">24</option>
      <option value="28px">28</option><option value="32px">32</option>
    </select>

    <button type="button" onclick="(function(){let url=prompt('Link URL:'); if(url){rteCmd('createLink', url);}})()">üîó</button>
    <button type="button" onclick="insertImageFromFile()">üñºÔ∏è Image</button>

    <select onchange="insertSymbol(this.value); this.selectedIndex=0;">
      <option>Symbol‚Ä¶</option><option>¬±</option><option>‚Üí</option><option>‚Üê</option>
      <option>‚â•</option><option>‚â§</option><option>¬µ</option><option>Œ©</option><option>‚àû</option>
    </select>
    <button type="button" onclick="rteCmd('removeFormat')">Remove format</button>

    <!-- Colour and table controls grouped with borders for clarity -->
    <div class="rte-group">
      <span class="label">Text colour</span>
      <div class="color-picker" title="Text colour">
        <button type="button" style="background:#000000" onclick="onRteColorButtonClick('foreColor','\u0023000000')"></button>
        <button type="button" style="background:#808080" onclick="onRteColorButtonClick('foreColor','\u0023808080')"></button>
        <button type="button" style="background:#ffffff" onclick="onRteColorButtonClick('foreColor','\u0023ffffff')"></button>
        <button type="button" style="background:#ff0000" onclick="onRteColorButtonClick('foreColor','\u0023ff0000')"></button>
        <button type="button" style="background:#0000ff" onclick="onRteColorButtonClick('foreColor','\u00230000ff')"></button>
        <button type="button" style="background:#008000" onclick="onRteColorButtonClick('foreColor','\u0023008000')"></button>
        <button type="button" style="background:#ffff00" onclick="onRteColorButtonClick('foreColor','\u0023ffff00')"></button>
      </div>
    </div>

    <div class="rte-group">
      <span class="label">Background</span>
      <div class="color-picker" title="Background colour">
        <button type="button" style="background:#000000" onclick="onRteColorButtonClick('hiliteColor','\u0023000000')"></button>
        <button type="button" style="background:#808080" onclick="onRteColorButtonClick('hiliteColor','\u0023808080')"></button>
        <button type="button" style="background:#ffffff" onclick="onRteColorButtonClick('hiliteColor','\u0023ffffff')"></button>
        <button type="button" style="background:#ff0000" onclick="onRteColorButtonClick('hiliteColor','\u0023ff0000')"></button>
        <button type="button" style="background:#0000ff" onclick="onRteColorButtonClick('hiliteColor','\u00230000ff')"></button>
        <button type="button" style="background:#008000" onclick="onRteColorButtonClick('hiliteColor','\u0023008000')"></button>
        <button type="button" style="background:#ffff00" onclick="onRteColorButtonClick('hiliteColor','\u0023ffff00')"></button>
      </div>
    </div>

    <div class="rte-group">
      <button type="button" onclick="insertTable()">üìä Table</button>
      <button type="button" title="Insert row" onclick="addTableRow()">‚ûïRow</button>
      <button type="button" title="Delete row" onclick="removeTableRow()">‚ûñRow</button>
      <button type="button" title="Insert column" onclick="addTableColumn()">‚ûïColumn</button>
      <button type="button" title="Delete column" onclick="removeTableColumn()">‚ûñColumn</button>
    </div>
  </div>
`;


 try { document.execCommand('styleWithCSS', false, true); } catch {}
  document.body.appendChild(box);

  // Schlie√üen
  document.getElementById('rte-close').onclick = hideRte;

  // Anpinnen
  const pinBtn = document.getElementById('rte-pin');
  pinBtn.onclick = ()=>{
    _rteState.pinned = !_rteState.pinned;
    pinBtn.classList.toggle('active', _rteState.pinned);
    if (!_rteState.pinned && _activeEditable) positionRte(_activeEditable);
  };

// Toolbar-Klicks: Auswahl sichern; nur Buttons "blocken", nicht Selects etc.
box.addEventListener('mousedown', (e)=>{
  saveSelection();
  const isButton = e.target.closest('button');
  if (isButton && _activeEditable) {
    e.preventDefault();           // Buttons sollen nicht den Fokus klauen
    _activeEditable.focus();
  }
});



// gespeicherte Position/Gr√∂√üe/Pin laden
const saved = JSON.parse(localStorage.getItem('rte_pos') || '{}');
if (Number.isFinite(saved.left))  box.style.left   = saved.left + 'px';
if (Number.isFinite(saved.top))   box.style.top    = saved.top  + 'px';
if (Number.isFinite(saved.width)  && saved.width  > 200) box.style.width  = saved.width  + 'px';
if (Number.isFinite(saved.height) && saved.height > 120) box.style.height = saved.height + 'px';
if (saved.pinned) {
  _rteState.pinned = true;
  pinBtn.classList.add('active');
}

// Gr√∂√üe beobachten (bei ‚Äûresize: both‚Äú) und speichern
const ro = new ResizeObserver(()=> saveRteBoxState());
ro.observe(box);

  // Draggen √ºber Header
  makeRteDraggable(box, document.getElementById('rte-handle'));

  // Repositionieren bei Scroll/Resize (nur wenn nicht angepinnt)
  window.addEventListener('scroll', ()=>{ if (_activeEditable && !_rteState.pinned) positionRte(_activeEditable); }, {passive:true});
  window.addEventListener('resize', ()=>{ if (_activeEditable && !_rteState.pinned) positionRte(_activeEditable); });
}

function showRte(el){
  _activeEditable = el;
  el.classList.add('rte-target');
  const f = document.getElementById('rte-float');
  if (f) {
    f.style.display = 'block';
    if (!_rteState.pinned) positionRte(el);
  }
}
function hideRte(){
  const f = document.getElementById('rte-float');
  if (f) f.style.display = 'none';
  if (_activeEditable) _activeEditable.classList.remove('rte-target');
  _activeEditable = null;
}

function positionRte(el){
  const f = document.getElementById('rte-float'); if (!f) return;
  if (_rteState.pinned) return;

  const r = el.getBoundingClientRect();
  const top = Math.max(8, window.scrollY + r.top - f.offsetHeight - 8);   // oberhalb des Feldes
  const left = Math.min(window.scrollX + r.left, window.scrollX + window.innerWidth - f.offsetWidth - 8);
  f.style.top = `${top}px`;
  f.style.left = `${left}px`;
}

function makeRteDraggable(box, handle){
  let dragging = false, startX=0, startY=0, startLeft=0, startTop=0, pid = null;

  const onPointerDown = (e)=>{
    // In der Header-Leiste: nicht starten, wenn ein interaktives Element geklickt wurde
    if (e.target.closest('button,select,input,label,a')) return;

    dragging = true;
    pid = e.pointerId;
    try { handle.setPointerCapture(pid); } catch {}
    startX = e.clientX; startY = e.clientY;
    startLeft = box.offsetLeft; startTop = box.offsetTop;
    e.preventDefault();
  };

  const onPointerMove = (e)=>{
    if(!dragging) return;
    const dx = e.clientX - startX, dy = e.clientY - startY;
    let left = startLeft + dx, top = startTop + dy;

    // im Viewport halten
    const minL = window.scrollX + 8;
    const minT = window.scrollY + 8;
    const maxL = window.scrollX + window.innerWidth  - box.offsetWidth  - 8;
    const maxT = window.scrollY + window.innerHeight - box.offsetHeight - 8;
    left = Math.min(Math.max(left, minL), Math.max(minL, maxL));
    top  = Math.min(Math.max(top,  minT), Math.max(minT, maxT));

    box.style.left = left + 'px';
    box.style.top  = top  + 'px';

    // beim manuellen Verschieben automatisch "pinnen"
    _rteState.pinned = true;
    document.getElementById('rte-pin')?.classList.add('active');
  };

  const stop = ()=>{
    if(!dragging) return;
    dragging = false;
    try { handle.releasePointerCapture(pid); } catch {}
    pid = null;
    saveRteBoxState();
  };

  handle.addEventListener('pointerdown', onPointerDown);
  handle.addEventListener('pointermove', onPointerMove);
  handle.addEventListener('pointerup', stop);
  handle.addEventListener('pointercancel', stop);
  handle.addEventListener('lostpointercapture', stop);
}



/* ===== Scroll-Persistenz f√ºr Editor ===== */
function getEditorScrollContainer(){
  return document.querySelector('#editor .scroll-table-container');
}
function saveEditorScroll(anchorId){
  const c = getEditorScrollContainer();
  const prev = JSON.parse(sessionStorage.getItem('editorScroll')||'{}');
  const state = {
    top: c ? c.scrollTop : (prev.top || 0),
    anchorId: anchorId || prev.anchorId || null,
  };
  sessionStorage.setItem('editorScroll', JSON.stringify(state));
}
function restoreEditorScroll(){
  const c = getEditorScrollContainer();
  if(!c) return;
  const s = JSON.parse(sessionStorage.getItem('editorScroll')||'{}');
  if (s.anchorId) {
    const row = document.querySelector(`#editor tr[data-qid="${s.anchorId}"]`);
    if (row) {
      row.scrollIntoView({ block: 'center' });
      row.classList.add('flash-highlight');
      setTimeout(()=>row.classList.remove('flash-highlight'), 1200);
      return;
    }
  }
  if (typeof s.top === 'number') c.scrollTop = s.top;
}

/*
 * Markiert eine Zeile in der Fragen-Datenbank als ausgew√§hlt. Beim
 * Aufrufen entfernt die Funktion die Markierung von der vorherigen
 * Zeile und f√ºgt sie der geklickten Zeile hinzu. Die zugeh√∂rige
 * Frage-ID wird in der globalen Variable `editorSelectedRowId`
 * gespeichert, so dass die Markierung beim erneuten √ñffnen der
 * Datenbank wieder hergestellt werden kann.
 */
function selectEditorRow(rowEl) {
  if (!rowEl) return;
  const id = rowEl.getAttribute('data-qid');
  // Entferne Markierung von der bisher ausgew√§hlten Zeile
  const prev = document.querySelector('#editor .selected-row');
  if (prev) prev.classList.remove('selected-row');
  // Markiere die neue Zeile
  rowEl.classList.add('selected-row');
  editorSelectedRowId = id;
}


/* ===== Editor ===== */
function showEditor() {
  loadQuestions();
  let missingSolutionCount = questions.filter(q => !q.solution || q.solution.length === 0).length;
  let missingAnswersCount = questions.filter(q => !q.answers || q.answers.length === 0).length;

  let missingSolutionNrs = questions.filter(q => !q.solution || q.solution.length === 0).map(q => q.nr || '?');
  let missingAnswersNrs  = questions.filter(q => !q.answers  || q.answers.length  === 0).map(q => q.nr || '?');

  let html = `<h3>Question Database <span style="font-size:0.85em; opacity:0.7;">(double‚Äëclick to edit)</span></h3>`;


  if(missingSolutionCount > 0 || missingAnswersCount > 0) {
    html += `<div style="margin-bottom:16px; padding:12px; background:color-mix(in srgb, Field 80%, yellow 20%); border:1px solid color-mix(in srgb, ButtonBorder 70%, orange 30%); border-radius:6px;">`;
    if(missingSolutionCount > 0) {
      html += `<div style="font-weight:bold; margin-bottom:8px;">‚ö†Ô∏è ${missingSolutionCount} questions without solution: No. ${missingSolutionNrs.join(', ')}</div>`;
    }
    if(missingAnswersCount > 0) {
      html += `<div style="font-weight:bold;">‚ùå ${missingAnswersCount} questions without answers: No. ${missingAnswersNrs.join(', ')}</div>`;
    }
    html += `</div>`;
  }
     // Gefilterte Liste erzeugen
     const filteredQuestions = questions; // Live-Filter passiert in der Tabelle

  // Action bar: arrange primary actions on the left and destructive ones on the right
  html += `<div style="margin-bottom:20px; display:flex; flex-wrap:wrap; align-items:center; gap:8px;">
    <button type="button" onclick="newQuestion()">New question</button>
    <button type="button" onclick="showImport()">Import</button>
    <button type="button" onclick="showExport()">Export</button>
    <button type="button" onclick="hideAll()">Back to dashboard</button>
    <span style="margin-left:auto; display:flex; flex-wrap:wrap; gap:8px;">
      <button type="button" onclick="resetProgress()" class="editor-reset-btn">Reset progress</button>
      <button type="button" class="delete-all-btn" onclick="deleteAllQuestions()">Delete all questions</button>
    </span>
    </div>`; 
  // Einzeilige Suchleiste (oberhalb der Tabelle)
  // Suchleiste: Suchtext persistent halten. Der aktuelle Suchbegriff wird in
  // editorSearch.text gespeichert und hier als value vorbelegt. Nur durch
  // Klick auf das ‚úï-Symbol oder ESC wird der Suchtext gel√∂scht.
  html += `<div class="editor-searchbar" style="display:flex; gap:8px; align-items:center; margin:12px 0;">
    <input id="editor-search" type="text" placeholder="Search in No. / Topic / Question / Date ‚Ä¶" style="flex:1; min-width:200px;" value="${escapeHTML(editorSearch.text || '')}">
    <button type="button" id="editor-search-clear" title="Clear search">‚úï</button>
    <span id="editor-search-count" style="opacity:.75; font-size:.9em;"></span>
  </div>`;
  // Tabellencontainer
   html += `<div class="scroll-table-container"><table>
    <thead>
      <tr>
        <th></th><th>No.</th><th>Topic</th><th>Question</th><th>Difficulty</th><th>Progress</th><th>Last answered</th>
      </tr>
    </thead>
    <tbody>
  `;
  filteredQuestions.forEach((q,i) => {
  let hasNoSolution = (!q.solution || q.solution.length === 0);
  let hasNoAnswers  = (!q.answers  || q.answers.length  === 0);
  let rowClass = (hasNoSolution || hasNoAnswers) ? 'class="missing-solution-row"' : '';
  let lastAnsweredFormatted = q.lastAnswered ? new Date(q.lastAnswered).toLocaleDateString('en-GB') : '-';

  // Such-‚ÄûHeuhaufen‚Äú: Nr, Thema, Fragetext, alle Datums-Varianten (de-DE + yyyy-mm-dd)
  const hayDate = d => {
    if (!d) return '';
    const x = new Date(d);
    if (!isFinite(+x)) return '';
    return `${x.toLocaleDateString('en-GB')} ${fmtYMD(x)}`;
  };
  const haystack = [
    String(q.nr ?? ''),
    String(q.topic ?? ''),
    stripHTML(q.text ?? ''),
    hayDate(q.createdAt),
    hayDate(q.updatedAt),
    hayDate(q.lastAnswered),
  ].join(' ').toLowerCase();

  html += `<tr ondblclick="editQuestion(questions.findIndex(x => x.id === '${q.id}'))" onclick="selectEditorRow(this)"
               ${rowClass}
               data-qid="${q.id}"
               data-haystack="${escapeHTML(haystack)}">
    <td><button type="button" class="delete-q-btn"
      onclick="event.stopPropagation(); deleteQuestion(questions.findIndex(x => x.id === '${q.id}'));">üóëÔ∏è</button></td>
    <td>${escapeHTML(q.nr ?? '')}</td>
    <td>${escapeHTML(q.topic ?? '')}</td>
    <td>${stripHTML(q.text ?? '')}</td>
    <td>${(() => {
      const d = q.difficulty;
      return escapeHTML(d === 'leicht' ? 'easy' : d === 'schwer' ? 'hard' : (d || ''));
    })()}</td>
    <td>${q.progress||0}</td>
    <td style="font-size:0.9em;">${lastAnsweredFormatted}</td>
  </tr>`;
});

  html += `</tbody></table></div>`;
  document.getElementById('editor').innerHTML = html;
  setupEditorSearch(); // neue einzeilige Suche initialisieren
  showOnly('editor');
  // Scroll-Position wiederherstellen
  setTimeout(restoreEditorScroll, 0);
  // Markierung der zuvor ausgew√§hlten Zeile wiederherstellen
  if (editorSelectedRowId) {
    const sel = document.querySelector(`#editor tr[data-qid="${editorSelectedRowId}"]`);
    if (sel) sel.classList.add('selected-row');
  }
}

async function deleteQuestion(idx) {
  if(await confirm("Do you really want to delete this question?")) {
    questions.splice(idx,1);
    saveQuestions();
    showEditor();
  }
}

async function deleteAllQuestions() {
  if(await confirm("‚ö†Ô∏è WARNING: All local questions will be permanently deleted!\n\nDo you really want to delete ALL questions?")) {
    if(await confirm("üî¥ FINAL WARNING: This operation cannot be undone!\n\nAll " + questions.length + " questions will be deleted. Proceed?")) {
      questions = [];
      saveQuestions();
      showEditor();
      await alert("‚úÖ All questions have been deleted.");
    }
  }
}

async function exportQuestions() {
  loadQuestions();
  if(questions.length === 0) {
    await alert("No questions available to export!");
    return;
  }
  const header = ['No.','Topic','Question','Answers','Correct answers','Comment','Progress','Difficulty','Created at','Last modified','Last answered','ID'];
  const rows = [header];
  for (const q of questions) {
    const answers = (q.answers || []).map(stripHTML);
    const solution = q.solution || [];
    const correctAnswers = solution.map(idx => answers[idx]).filter(Boolean);
    rows.push([
      q.nr || '',
      q.topic || '',
      stripHTML(q.text || ''),
      answers.join('\n'),
      correctAnswers.join('\n'),
      stripHTML(q.comment || ''),
      q.progress || 0,
      q.difficulty || 'leicht',
      q.createdAt ? formatDateYYYYMMDD(new Date(q.createdAt)) : '',
      q.updatedAt ? formatDateYYYYMMDD(new Date(q.updatedAt)) : '',
      q.lastAnswered ? formatDateYYYYMMDD(new Date(q.lastAnswered)) : '',
      q.id || ''
    ]);
  }
  const ws = XLSX.utils.aoa_to_sheet(rows);
  const wb = XLSX.utils.book_new();
  XLSX.utils.book_append_sheet(wb, ws, 'Fragen');
  const filename = `Quiz_Export_${new Date().toISOString().split('T')[0]}.xlsx`;
  XLSX.writeFile(wb, filename);
  await alert(`‚úÖ Export successful!\n${questions.length} questions have been saved as "${filename}".`);
}

/* ===== Export mit Optionen =====
 *
 * Die Funktion showExport() √∂ffnet eine einfache Oberfl√§che im Importer‚ÄëContainer,
 * √ºber die der Anwender ausw√§hlen kann, ob die Formatierung der Texte
 * erhalten bleiben soll und in welchem Dateiformat exportiert wird
 * (Excel oder JSON). Nach der Auswahl ruft performExport() die
 * entsprechenden Exportfunktionen auf. Diese l√∂sen den Download aus
 * und aktualisieren optional die Dataset‚ÄëMetadaten.
 */
function showExport() {
  loadQuestions();
  if (questions.length === 0) {
    alert("No questions available to export!");
    return;
  }
  let html = `<h3>Export</h3>
    <div style="margin-bottom:12px;">
      <label><input type="checkbox" id="export-formatting" checked> Keep formatting</label>
    </div>
    <div style="margin-bottom:12px;">
      <label><input type="radio" name="export-type" value="excel" checked> Excel (.xlsx)</label>
      <label style="margin-left:12px;"><input type="radio" name="export-type" value="json"> JSON (.json)</label>
    </div>
    <button type="button" onclick="performExport()">Export</button>
    <button type="button" onclick="showEditor()">Cancel</button>`;
  const importer = document.getElementById('importer');
  importer.innerHTML = html;
  showOnly('importer');
}

async function performExport() {
  const keepFmt = document.getElementById('export-formatting').checked;
  const typeRadio = document.querySelector('input[name="export-type"]:checked');
  const type = typeRadio ? typeRadio.value : 'excel';
  if (type === 'json') {
    await exportQuestionsJSON(keepFmt);
  } else {
    await exportQuestionsExcel(keepFmt);
  }
  // Nach dem Export zur√ºck zur Fragenliste
  showEditor();
}

async function exportQuestionsExcel(keepFormatting) {
  loadQuestions();
  const header = ['No.','Topic','Question','Answers','Correct answers','Comment','Progress','Difficulty','Created at','Last modified','Last answered','ID'];
  const rows = [header];
  for (const q of questions) {
    const answers = (q.answers || []).map(ans => keepFormatting ? sanitizeHTML(ans || '') : stripHTML(ans || ''));
    const solution = q.solution || [];
    const correctAnswers = solution.map(idx => answers[idx]).filter(Boolean);
    rows.push([
      q.nr || '',
      q.topic || '',
      keepFormatting ? sanitizeHTML(q.text || '') : stripHTML(q.text || ''),
      answers.join('\n'),
      correctAnswers.join('\n'),
      keepFormatting ? sanitizeHTML(q.comment || '') : stripHTML(q.comment || ''),
      q.progress || 0,
      q.difficulty || 'leicht',
      q.createdAt ? formatDateYYYYMMDD(new Date(q.createdAt)) : '',
      q.updatedAt ? formatDateYYYYMMDD(new Date(q.updatedAt)) : '',
      q.lastAnswered ? formatDateYYYYMMDD(new Date(q.lastAnswered)) : '',
      q.id || ''
    ]);
  }
  const ws = XLSX.utils.aoa_to_sheet(rows);
  const wb = XLSX.utils.book_new();
  XLSX.utils.book_append_sheet(wb, ws, 'Fragen');
  // Version hochz√§hlen wenn m√∂glich
  let nextVersion = 1;
  if (datasetVersion && !isNaN(parseInt(datasetVersion))) nextVersion = parseInt(datasetVersion) + 1;
  const today = new Date().toISOString().split('T')[0];
  const filename = `Quiz_Export_${today}_${nextVersion}.xlsx`;
  XLSX.writeFile(wb, filename);
  // Update dataset info to new export
  updateDatasetInfo(filename, String(nextVersion), new Date().toLocaleDateString('en-GB'));
  await alert(`‚úÖ Export successful!\n${questions.length} questions have been saved as "${filename}".`);
}

async function exportQuestionsJSON(keepFormatting) {
  loadQuestions();
  const exportList = questions.map(q => {
    return {
      id: q.id || generateId(),
      nr: q.nr || '',
      topic: q.topic || '',
      text: keepFormatting ? sanitizeHTML(q.text || '') : stripHTML(q.text || ''),
      answers: (q.answers || []).map(ans => keepFormatting ? sanitizeHTML(ans || '') : stripHTML(ans || '')),
      solution: Array.isArray(q.solution) ? q.solution.slice() : [],
      comment: keepFormatting ? sanitizeHTML(q.comment || '') : stripHTML(q.comment || ''),
      progress: q.progress || 0,
      difficulty: q.difficulty || 'leicht',
      createdAt: q.createdAt || new Date().toISOString(),
      updatedAt: q.updatedAt || new Date().toISOString(),
      lastAnswered: q.lastAnswered || null,
      history: Array.isArray(q.history) ? q.history : []
    };
  });
  // Version hochz√§hlen
  let nextVersion = 1;
  if (datasetVersion && !isNaN(parseInt(datasetVersion))) nextVersion = parseInt(datasetVersion) + 1;
  const today = new Date().toISOString().split('T')[0];
  const filename = `Quiz_Export_${today}_${nextVersion}.json`;
  const blob = new Blob([JSON.stringify(exportList, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = filename;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
  updateDatasetInfo(filename, String(nextVersion), new Date().toLocaleDateString('en-GB'));
  await alert(`‚úÖ Export successful!\n${questions.length} questions have been saved as "${filename}".`);
}

async function resetProgress() {
  if(await confirm("‚ö†Ô∏è WARNING: Progress and all 'last answered' dates of all questions will be reset to zero!\n\nProceed?")) {
    questions.forEach(q => { q.progress = 0; q.lastAnswered = null; q.history = []; });
    saveQuestions();
    showEditor();
    await alert("‚úÖ Progress and history of all questions have been reset.");
  }
}

function showEditDialog(q, idx) {
  loadQuestions();
  const themenSet = new Set(questions.map(qq => qq.topic).filter(Boolean));
  const themenOpt = Array.from(themenSet).map(t => `<option value="${escapeHTML(t)}">`).join('');

  const html = `
    <div class="modal-header" id="modal-header">
      <h4 style="margin:0;">${idx>=0?'Edit question':'New question'}</h4>
    </div>
    <div>
      <input type="hidden" id="qid" value="${q.id || ''}">
      <label>No.: <input type="number" id="nr" value="${q.nr||''}" style="width: 100px;"></label><br>
      <label>Topic: <input id="topic" list="themenlist" value="${escapeHTML(q.topic||'')}" style="width:300px;">
        <datalist id="themenlist">${themenOpt}</datalist></label><br>

      <div style="margin-top:8px;font-weight:600">Question text</div>
      
      <div id="qtext">${renderHTML(q.text||'')}</div>

      <label style="display:block;margin-top:12px;">Difficulty:
        <!-- Die ID des Schwierigkeits-Selects wird umbenannt, um Kollisionen
             mit dem Quiz-Filter (#qdifficulty) zu vermeiden. -->
        <select id="ed-qdifficulty">
          <option value="leicht" ${q.difficulty==='leicht'?'selected':''}>easy</option>
          <option value="schwer" ${q.difficulty==='schwer'?'selected':''}>hard</option>
        </select>
      </label>
      <label>Progress: <input type="number" id="qprogress" min="0" step="1" value="${q.progress || 0}" style="width: 100px;"></label><br>

      <div style="margin-top:10px;">Answer options <span style="opacity:.8">(select at least one correct answer)</span></div>
      <div id="answers"></div>
      <button type="button" id="add-ans-btn" title="Add answer" onclick="addAnswerField()">‚ûï Add answer</button>
      
      <div style="margin-top:12px;font-weight:600">Comment</div>
      <div id="qcomment" style="min-height:220px; max-height:60vh; overflow:auto;">
        ${renderHTML(q.comment||'')}
        </div>

      <div class="modal-actions">
        <button type="button" onclick="saveEdit(${idx})">Save</button>
        <button type="button" onclick="closeModal()">Cancel</button>
      </div>
    </div>`;

  document.getElementById('modal-content').innerHTML = html;
  document.getElementById('edit-modal').style.display = 'flex';

  setTimeout(() => {
    bindEditable(document.getElementById('qtext'));
    bindEditable(document.getElementById('qcomment'));
    loadAnswerFields(q);
    makeDraggable('modal-content','modal-header');
    bringToFront('edit-modal');
  }, 20);
}


function autoGrow(el) { el.style.height = "auto"; el.style.height = (el.scrollHeight+2)+"px"; }

function answerField(txt, checked, idx) {
  let d = document.createElement('div');
  d.className = 'answer';
  d.innerHTML = `
    <button type="button" class="delete-ans-btn" onclick="deleteAnswerField(${idx})">üóëÔ∏è</button>
    <input type="checkbox" class="chk" ${checked ? 'checked' : ''} title="richtig?">
    <div class="anstxt">${renderHTML(txt || '')}</div>`;
  setTimeout(()=>{
    const box = d.querySelector('.anstxt');
    bindEditable(box);
  },0);
  return d;
}


function bindDelBtns() {
  let ansDiv = document.getElementById('answers');
  Array.from(ansDiv.querySelectorAll('.delete-ans-btn')).forEach((btn, i) => {
    btn.onclick = function() { deleteAnswerField(i); };
  });
}

function loadAnswerFields(q) {
  let answers = q.answers || [];
  let solution = q.solution || [];
  let ansDiv = document.getElementById('answers');
  ansDiv.innerHTML = '';
  for(let i=0;i<answers.length;i++) ansDiv.appendChild(answerField(answers[i], solution.includes(i), i));
  bindDelBtns();
}

function addAnswerField() {
  let ansDiv = document.getElementById('answers');
  if(ansDiv.querySelectorAll('.answer').length >= 6) { alert("Maximal 6 Auswahlantworten"); return; }
  ansDiv.appendChild(answerField('', false, ansDiv.querySelectorAll('.answer').length));
  bindDelBtns();
}
function deleteAnswerField(idx) {
  let ansDiv = document.getElementById('answers');
  if(ansDiv.children[idx]) ansDiv.removeChild(ansDiv.children[idx]);
  bindDelBtns();
}

function makeDraggable(contentId, headerId){
  let modal = document.getElementById(contentId);
  let header = document.getElementById(headerId);
  if(!header) return;
  let shiftX=0, shiftY=0, dragging=false;
  header.onmousedown = (e)=>{
    e.preventDefault();
    let rect = modal.getBoundingClientRect();
    shiftX = e.clientX - rect.left;
    shiftY = e.clientY - rect.top;
    document.onmouseup = ()=>{ dragging=false; document.onmouseup=null; document.onmousemove=null; };
    document.onmousemove = (e2)=>{
      if(!dragging) dragging=true;
      e2.preventDefault();
      let newLeft = e2.clientX - shiftX;
      let newTop  = e2.clientY - shiftY;
      newLeft = Math.max(0, Math.min(window.innerWidth - modal.offsetWidth, newLeft));
      newTop  = Math.max(0, Math.min(window.innerHeight - modal.offsetHeight, newTop));
      modal.style.left = newLeft + "px";
      modal.style.top  = newTop  + "px";
      modal.style.position = 'absolute';
    };
  };
}
function bringToFront(modalId){ let m=document.getElementById(modalId); if(m) m.style.zIndex=9999; }
function closeModal(){ document.getElementById('edit-modal').style.display='none'; document.getElementById('preview-modal').style.display='none'; }

function nextNr(){
  loadQuestions();
  let used = new Set(questions.map(q=>parseInt(q.nr)||0));
  let nr = 1; while(used.has(nr)) nr++;
  return nr;
}
function newQuestion(){ showEditDialog({ id: generateId(), nr: nextNr(), topic:'', text:'', answers:[], solution:[], comment:'', progress:0, difficulty:'leicht', history:[] }, -1); }
window.editQuestion = function(idx){ showEditDialog(questions[idx], idx); };

/* ===== Import ===== */
function showImport() {
  let html = `<h3>Import from Excel/CSV file</h3>
    <input type="file" id="file-input" accept=".xlsx,.xls,.json"><br>
    <button type="button" onclick="showEditor()">Back</button>
    <div style="font-size:0.95em; opacity:0.8; margin: 16px 0;">
      <strong>Required columns:</strong> No., Topic, Question, Answers, Correct answer(s), Comment, Progress, Difficulty<br>
      <strong>Optional columns:</strong> Created at, Last modified, Last answered, ID<br>
      Enter each answer and solution on a separate line within its cell.<br>
      <strong>Date formats are recognized automatically (e.g. dd.mm.yyyy ‚Üí yyyy-mm-dd).</strong>
    </div>
    <div id="import-preview"></div>`;
  document.getElementById('importer').innerHTML = html;
  showOnly('importer');
  document.getElementById('file-input').addEventListener('change', handleImport);
}

function nameArrayKeys(headerArr){
  let out={};
  headerArr.forEach((h,i)=>{ if(typeof h === "string" && h.trim() !== "") out[h.trim()] = i; });
  return out;
}

/**
 * Filter imported questions against the existing database.
 * Running numbers are intentionally ignored because they may differ between imports.
 * A question is considered a duplicate if its text (ignoring HTML) and its answer set
 * and comment match an existing question in the local database.
 * Returns an object with the filtered list and the number of duplicates detected.
 */
function filterExistingQuestions(list) {
  loadQuestions();
  let duplicateCount = 0;
  const filteredList = [];
  list.forEach(item => {
    const isDuplicate = questions.some(q => {
      // compare text without HTML and trimmed/lowercased
      const txtA = (q.text || '').replace(/<[^>]+>/g, '').trim().toLowerCase();
      const txtB = (item.text || '').replace(/<[^>]+>/g, '').trim().toLowerCase();
      if (txtA !== txtB) return false;
      // compare answers ignoring order, HTML and case
      const ansA = (q.answers || []).map(a => stripHTML(a).trim().toLowerCase()).sort();
      const ansB = (item.answers || []).map(a => stripHTML(a).trim().toLowerCase()).sort();
      const commentA = stripHTML(q.comment || '').trim().toLowerCase();
      const commentB = stripHTML(item.comment || '').trim().toLowerCase();
      return JSON.stringify(ansA) === JSON.stringify(ansB) && commentA === commentB;
    });
    if (isDuplicate) {
      duplicateCount++;
    } else {
      filteredList.push(item);
    }
  });
  return { filteredList, duplicateCount };
}

// Import only the questions selected by the user in the preview table. The full import list
// is passed as a serialized JSON string via the onclick handler in showImportPreview().
// This function collects all checked rows (based on the `data-index` attribute on the
// checkbox inputs) and constructs a new list containing only those entries. It then
// invokes the existing confirmImport() function with the selected subset. If the user
// has not selected any items, a simple alert informs them that at least one question
// must be chosen before proceeding.
function confirmImportSelected(listStr) {
  try {
    // If listStr is already an array (because the JSON was inlined in the onclick),
    // we use it directly. Otherwise attempt to parse a JSON string.
    let importList;
    if (Array.isArray(listStr)) {
      importList = listStr;
    } else {
      importList = JSON.parse(listStr);
    }
    const checkboxes = document.querySelectorAll('.import-select');
    const selected = [];
    checkboxes.forEach(cb => {
      if (cb.checked) {
        const idx = parseInt(cb.dataset.index, 10);
        if (!isNaN(idx)) selected.push(importList[idx]);
      }
    });
    if (selected.length === 0) {
      alert('Please select at least one question to import.');
      return;
    }
    confirmImport(JSON.stringify(selected));
  } catch(err) {
    console.error('Error during selected import:', err);
    alert('An unexpected error occurred while importing selected questions.');
  }
}

function handleImport(e) {
  let f = e.target.files[0];
  if (!f) return;
  // Lese Metadaten aus Dateinamen und Zeitstempel f√ºr den Fortschrittsbalken
  const name = f.name;
  const verMatch = name.match(/_(\d+)(?=\.(xlsx|xls|json))/);
  const version = verMatch ? verMatch[1] : '';
  const lastModDate = new Date(f.lastModified);
  updateDatasetInfo(name, version, lastModDate.toLocaleDateString('en-GB'));

  // Wenn eine JSON‚ÄëDatei importiert wird, parse sie als Text
  const lowerName = name.toLowerCase();
  if (lowerName.endsWith('.json')) {
    const reader = new FileReader();
    reader.onload = function(evt) {
      try {
        const jsonData = JSON.parse(evt.target.result);
        handleJsonImport(jsonData);
      } catch(err) {
        alert('Invalid JSON file.');
        console.error(err);
      }
    };
    reader.readAsText(f);
    return;
  }

  // Standard: Excel/CSV importieren
  const reader = new FileReader();
  reader.onload = function(evt) {
    let data = evt.target.result;
    let workbook = XLSX.read(data, {type: 'binary'});
    let sheet = workbook.Sheets[workbook.SheetNames[0]];
    let arr = XLSX.utils.sheet_to_json(sheet, {header:1, blankrows:false});
    let nak = nameArrayKeys(arr[0] || []);
    let previewList = [];
    let invalidCount = 0, partialMatchCount = 0;
    let partialMatchDetails = [];

    // vorhandene Nummern sichern, um Kollisionen zu vermeiden
    const existingNrs = new Set(questions.map(q=>parseInt(q.nr)||0));

    for (let i=1; i<arr.length; i++) {
      let row = arr[i]; if(!row) continue;
      if(!row[nak['Frage']] || !row[nak['Auswahlantworten']]) continue;

      // Nummer √ºbernehmen oder neue freie w√§hlen
      let rawNr = parseInt(row[nak['Lfd Nummer']])||1;
      let nr = rawNr;
      while(existingNrs.has(nr)) nr++;
      existingNrs.add(nr);

      // Antworten parsen/trimmen
      let ansList = (row[nak['Auswahlantworten']]+'').split(/\r?\n/).map(x=>x.trim()).filter(x=>x.length>0);
      let solList = (row[nak['Richtige Antworten']]+'').split(/\r?\n/).map(x=>x.trim()).filter(x=>x.length>0);

      // L√∂sungen anhand der ersten 18 Zeichen matchen
      let solution = [], unmatchedSolutions = [];
      solList.forEach(solAnswer => {
        let ansShort = solAnswer.substring(0, Math.min(18, solAnswer.length));
        let foundIndex = ansList.findIndex(fullAns => fullAns.substring(0, Math.min(18, fullAns.length)) === ansShort);
        if(foundIndex >= 0) solution.push(foundIndex);
        else unmatchedSolutions.push(solAnswer);
      });

      let hasSolution = solution.length > 0;
      let hasPartialMatch = unmatchedSolutions.length > 0 && hasSolution;
      if(!hasSolution) invalidCount++;
      if(hasPartialMatch) {
        partialMatchCount++;
        partialMatchDetails.push({
          nr,
          question: String(row[nak['Frage']]).substring(0,50)+'...',
          totalSolutions: solList.length,
          foundSolutions: solution.length,
          unmatchedSolutions
        });
      }

      // Datumsfelder robust parsen (Excel-Seriennummern, dd.mm.yyyy, ISO etc.)
      const createdISO = (nak['Erstellt am'] && row[nak['Erstellt am']]!=null) ? parseToISO(row[nak['Erstellt am']]) : null;
      const updatedISO = (nak['Zuletzt ge√§ndert'] && row[nak['Zuletzt ge√§ndert']]!=null) ? parseToISO(row[nak['Zuletzt ge√§ndert']]) : null;
      const lastISO    = (nak['Zuletzt beantwortet'] && row[nak['Zuletzt beantwortet']]!=null) ? parseToISO(row[nak['Zuletzt beantwortet']]) : null;

      // ID aus Datei oder neu
      const importedId = nak['ID'] && row[nak['ID']] ? String(row[nak['ID']]).trim() : null;

      previewList.push({
        id: importedId || generateId(),
        nr,
        topic: row[nak['Thema']] ? String(row[nak['Thema']]).trim() : '',
        text:  row[nak['Frage']] ? String(row[nak['Frage']]).trim() : '',
        answers: ansList,
        solution,
        comment: row[nak['Kommentar']] ? String(row[nak['Kommentar']]).trim() : '',
        progress: parseInt(row[nak['Fortschritt']])||0,
        difficulty: row[nak['Schwierigkeit']] ? String(row[nak['Schwierigkeit']]).trim() : 'leicht',
        createdAt: createdISO || new Date().toISOString(),
        updatedAt: updatedISO || new Date().toISOString(),
        lastAnswered: lastISO || null,
        history: [], // kann sp√§ter aus progress/lastAnswered rekonstruiert werden
        markMissing: !hasSolution,
        hasPartialMatch: hasPartialMatch,
        unmatchedSolutions
      });
    }
    // Filter out questions that already exist in the current database.
    const { filteredList, duplicateCount } = filterExistingQuestions(previewList);
    showImportPreview(filteredList, invalidCount, partialMatchCount, partialMatchDetails, duplicateCount);
  };
  reader.readAsBinaryString(f);
}

// Importiert eine Liste von Fragen aus einer JSON‚ÄëStruktur. Die JSON‚ÄëDatei
// sollte ein Array von Objekten enthalten, das m√∂glichst den gleichen
// Aufbau wie unsere internen Fragenobjekte besitzt. F√ºr jede Frage wird
// ein neuer Lfd. Nr. vergeben, falls die Nummer bereits existiert.
// Fragen ohne L√∂sungen werden gelb markiert wie beim Excel‚ÄëImport.
function handleJsonImport(data) {
  try {
    if (!Array.isArray(data)) {
      alert('JSON muss ein Array von Fragen enthalten.');
      return;
    }
    let previewList = [];
    let invalidCount = 0;
    const existingNrs = new Set(questions.map(q => parseInt(q.nr) || 0));
    data.forEach(item => {
      if (!item || typeof item !== 'object') return;
      if (!item.text || !item.answers) return;
      // Nummer √ºbernehmen oder neue freie w√§hlen
      let rawNr = parseInt(item.nr) || 1;
      let nr = rawNr;
      while (existingNrs.has(nr)) nr++;
      existingNrs.add(nr);
      // Antworten
      let ansList = Array.isArray(item.answers) ? item.answers.map(a => String(a)) : [];
      let solList = Array.isArray(item.solution) ? item.solution.filter(ix => typeof ix === 'number') : [];
      if (!solList || solList.length === 0) invalidCount++;
      previewList.push({
        id: item.id || generateId(),
        nr,
        topic: item.topic || '',
        text: item.text || '',
        answers: ansList,
        solution: solList,
        comment: item.comment || '',
        progress: parseInt(item.progress) || 0,
        difficulty: item.difficulty || 'leicht',
        createdAt: item.createdAt || new Date().toISOString(),
        updatedAt: item.updatedAt || new Date().toISOString(),
        lastAnswered: item.lastAnswered || null,
        history: Array.isArray(item.history) ? item.history : [],
        markMissing: !solList || solList.length === 0,
        hasPartialMatch: false,
        unmatchedSolutions: []
      });
    });
    // F√ºr JSON‚ÄëImport haben wir keine partiell erkannten L√∂sungen, daher
    // wird partialMatchCount auf 0 gesetzt.
    // Filter out questions that already exist in the current database.
    const { filteredList, duplicateCount } = filterExistingQuestions(previewList);
    // No partial matches for JSON import, pass 0 and empty array.
    showImportPreview(filteredList, invalidCount, 0, [], duplicateCount);
  } catch(err) {
    console.error(err);
    alert('Error processing the JSON data.');
  }
}

function showImportPreview(list, invalidCount, partialMatchCount, partialMatchDetails, duplicateCount = 0) {
  let html = `<div class="scroll-table-container" style="height:40vh;">
    <table>
    <thead>
      <tr><th>Select</th><th>No.</th><th>Topic</th><th>Question</th><th>Answers</th><th>Correct answer(s)</th><th>Comment</th><th>Difficulty</th></tr>
    </thead>
    <tbody>`;
  list.forEach((q, idx) => {
    let rowClass = q.markMissing ? 'class="missing-solution-row"' : (q.hasPartialMatch ? 'class="partial-match-row"' : '');
    html += `<tr ${rowClass}>
      <td><input type="checkbox" class="import-select" data-index="${idx}" checked></td>
      <td>${q.nr}</td>
      <td>${escapeHTML(q.topic)}</td>
      <td>${escapeHTML(q.text)}</td>
      <td>${q.answers.map(escapeHTML).join('<br>')}</td>
      <td>${q.solution.map(ix=>escapeHTML(q.answers[ix]||'')).join('<br>')}</td>
      <td>${escapeHTML(q.comment)}</td>
      <td>${escapeHTML(q.difficulty)}</td>
    </tr>`;
  });
  html += `</tbody></table></div><div style="margin-top:16px;">`;
  if(invalidCount > 0) html += `<div style="font-weight:bold; margin-bottom:12px;">‚ö†Ô∏è ${invalidCount} questions have no solution and are highlighted in yellow!</div>`;
  if(partialMatchCount > 0) {
    html += `<div style="font-weight:bold; margin-bottom:12px;">üî∏ ${partialMatchCount} questions with partially recognized solutions (highlighted in orange):</div>
      <div style="background:color-mix(in srgb, Field 85%, yellow 15%); padding:12px; border-radius:6px; margin-bottom:12px; font-size:0.9em;">`;
    partialMatchDetails.forEach(d=>{
      html += `<div style="margin-bottom:8px;">
        <strong>No. ${d.nr}:</strong> "${escapeHTML(d.question)}"<br>
        <span style="opacity:0.8;">Expected: ${d.totalSolutions} solutions, Recognized: ${d.foundSolutions}</span><br>
        <span style="opacity:0.7;">Not recognized: ${d.unmatchedSolutions.map(escapeHTML).join(', ')}</span>
      </div>`;
    });
    html += `</div>`;
  }
  // Inform about duplicates and new question count
  if (duplicateCount > 0) {
    html += `<div style="font-weight:bold; margin-bottom:12px;">üîÅ ${duplicateCount} existing question(s) were ignored and will not be imported.</div>`;
  }
  html += `<div style="font-weight:bold; margin-bottom:12px;">${list.length} new question(s) detected. Select the ones you want to import below.</div>`;
  html += `<div style="font-weight:bold;">üìä Date formats have been normalized.</div>
      <p style="margin-top:12px;">Would you like to import the selected questions?</p>
    </div>`;

  const safeJSON = JSON.stringify(list).replace(/'/g,"&#39;").replace(/"/g,"&quot;");
  let conflictCount = invalidCount + partialMatchCount;
  if(conflictCount > 0) {
    html += `<button type="button" onclick='startConflictCorrections(${safeJSON})'>Resolve conflicts (${conflictCount})</button>`;
  } else {
    html += `<button type="button" onclick='confirmImportSelected(${safeJSON})'>Import selected</button>`;
  }
  html += `<button type="button" onclick="showImport()">Cancel</button>`;
  document.getElementById('import-preview').innerHTML = html;
}

/* Konflikt-Korrekturen */
function showConflictCorrectionDialog(conflictList, startIdx, originalImportList) {
  if(startIdx >= conflictList.length) { confirmImport(JSON.stringify(originalImportList)); return; }
  let q = conflictList[startIdx];
  let ansHtml = q.answers.map((ans, i) =>
    `<div style="margin-bottom:8px; display:flex; align-items:center; gap:8px;">
      <input type="checkbox" id="confchk-${i}" ${q.solution.includes(i)?'checked':''} style="min-width:18px;">
      <input type="text" value="${escapeHTML(ans)}" id="confans-${i}" style="flex:1; min-width:200px;">
    </div>`).join('');
  let unmatchedHtml = q.unmatchedSolutions && q.unmatchedSolutions.length > 0
    ? `<div style="margin-bottom:12px; padding:8px; background:color-mix(in srgb, Field 70%, orange 30%); border-radius:4px;">
        <strong>Unassigned solutions:</strong><br>${q.unmatchedSolutions.map(escapeHTML).join('<br>')}
       </div>` : '';
  let dlgHtml = `<div class="modal-header"><h4 style="margin:0;">Conflict resolution ‚Äì Question No. ${q.nr} (${startIdx+1}/${conflictList.length})</h4></div>
    <div style="max-height:70vh; overflow-y:auto;">
      <div style="margin-bottom:16px;">
        <strong>Question text:</strong><br>
        <div style="padding:8px; background:color-mix(in srgb, Field 90%, blue 10%); border-radius:4px; margin-top:4px;">${escapeHTML(q.text)}</div>
      </div>
      ${unmatchedHtml}
      <div style="margin-bottom:16px;">
        <strong>Edit answers (checkbox = correct answer):</strong><br>
        <div style="margin-top:8px;">${ansHtml}</div>
        <button type="button" onclick="addConflictAnswer()" style="margin-top:8px; font-size:0.9em;">‚ûï Add answer</button>
      </div>
      <div style="margin-bottom:16px;">
        <strong>Comment:</strong><br>
        <textarea id="confcomment" style="width:98%; height:60px; resize:vertical; margin-top:4px;">${escapeHTML(q.comment||'')}</textarea>
      </div>
      <div style="border-top:1px solid ButtonBorder; padding-top:16px;">
        <button type="button" onclick="acceptCorrection(${startIdx})">‚úÖ Accept & Next</button>
        <button type="button" onclick="skipCorrection(${startIdx})">‚è≠Ô∏è Skip & Next</button>
        <button type="button" onclick="cancelConflictCorrection()">‚ùå Cancel</button>
      </div>
    </div>`;
  document.getElementById('preview-content').innerHTML = dlgHtml;
  document.getElementById('preview-modal').style.display = 'flex';
  window._conflictList = conflictList;
  window._originalImportList = originalImportList;
  window._conflictIdx = startIdx;
}
function addConflictAnswer() {
  let q = window._conflictList[window._conflictIdx];
  let newIdx = q.answers.length;
  q.answers.push('');
  let container = document.querySelector('#preview-content div:nth-child(3) div');
  let newDiv = document.createElement('div');
  newDiv.style.cssText = 'margin-bottom:8px; display:flex; align-items:center; gap:8px;';
  newDiv.innerHTML = `<input type="checkbox" id="confchk-${newIdx}" style="min-width:18px;">
    <input type="text" value="" id="confans-${newIdx}" style="flex:1; min-width:200px;" placeholder="Neue Antwort eingeben">`;
  container.appendChild(newDiv);
}
async function acceptCorrection(idx) {
  let q = window._conflictList[idx];
  let newAns = [], newSol = [];
  let i = 0;
  while(document.getElementById('confans-'+i)) {
    let txt = document.getElementById('confans-'+i).value.trim();
    if(txt.length>0){ newAns.push(txt); if(document.getElementById('confchk-'+i).checked) newSol.push(newAns.length-1); }
    i++;
  }
  if(newSol.length === 0) { await alert('‚ö†Ô∏è At least one answer must be marked as correct!'); return; }
  q.answers = newAns; q.solution = newSol; q.comment = document.getElementById('confcomment').value.trim();
  q.markMissing = false; q.hasPartialMatch = false;
  let idxOrig = window._originalImportList.findIndex(qq => qq.nr === q.nr);
  if(idxOrig >= 0) window._originalImportList[idxOrig] = q;
  document.getElementById('preview-modal').style.display = 'none';
  showConflictCorrectionDialog(window._conflictList, idx + 1, window._originalImportList);
}
function skipCorrection(idx){
  document.getElementById('preview-modal').style.display = 'none';
  showConflictCorrectionDialog(window._conflictList, idx + 1, window._originalImportList);
}
function cancelConflictCorrection(){ document.getElementById('preview-modal').style.display = 'none'; showImport(); }
function startConflictCorrections(importListStr) {
  let importList = typeof importListStr === 'string' ? JSON.parse(importListStr.replace(/&quot;/g,'"').replace(/&#39;/g,"'")) : importListStr;
  let conflicts = importList.filter(q => q.markMissing || q.hasPartialMatch);
  if(conflicts.length === 0) { confirmImport(JSON.stringify(importList)); return; }
  showConflictCorrectionDialog(conflicts, 0, importList);
}

/*
 * Shows a detailed table comparing imported questions with existing ones when their IDs collide.
 * Each conflicting entry is presented as a set of rows where the left column lists the field name,
 * the second column shows the value currently stored in the database, and the third column shows
 * the value from the import. Differences are highlighted. A dropdown in the fourth column lets
 * the user decide whether to skip the import or replace the existing question. When the user
 * clicks "Apply", the selected actions are executed and the editor is shown.
 */
function showDuplicateTable(fullList, collisions) {
  loadQuestions();
  window._dupFullList = fullList;
  window._dupCollisions = collisions;
  const container = document.getElementById('importer');
  let html = `<h3>Duplicate ID conflicts</h3>`;
  html += `<div class="scroll-table-container" style="max-height:55vh;">
    <table>
    <thead>
      <tr><th style="min-width:40px;">No.</th><th>Field</th><th>Existing</th><th>Import</th><th style="min-width:120px;">Action</th></tr>
    </thead><tbody>`;
  collisions.forEach((imp, idx) => {
    const existing = questions.find(q => q.id === imp.id) || {};
    const fields = ['nr','topic','text','answers','solution','comment','difficulty'];
    fields.forEach((f, fi) => {
      html += `<tr${fi === 0 ? ' style="border-top:2px solid ButtonBorder;"' : ''}>`;
      if (fi === 0) {
        html += `<td rowspan="${fields.length}">${escapeHTML(String(imp.nr || ''))}</td>`;
      }
      const fieldNames = {
        nr: 'No.',
        topic: 'Topic',
        text: 'Question',
        answers: 'Answers',
        solution: 'Correct answer(s)',
        comment: 'Comment',
        difficulty: 'Difficulty'
      };
      html += `<td>${fieldNames[f] || f}</td>`;
      let oldVal = existing[f];
      let newVal = imp[f];
      // Format arrays for display
      const formatVal = v => {
        if (Array.isArray(v)) {
          return v.map(x => escapeHTML(String(x))).join('<br>');
        }
        return escapeHTML(v == null ? '' : String(v));
      };
      let oldDisplay = '';
      let newDisplay = '';
      if (f === 'answers') {
        oldDisplay = Array.isArray(oldVal) ? oldVal.map(ans => escapeHTML(ans)).join('<br>') : '';
        newDisplay = Array.isArray(newVal) ? newVal.map(ans => escapeHTML(ans)).join('<br>') : '';
      } else if (f === 'solution') {
        // translate indices to answer texts
        oldDisplay = Array.isArray(oldVal) && Array.isArray(existing.answers)
          ? oldVal.map(ix => escapeHTML(existing.answers[ix] || '')).join('<br>') : '';
        newDisplay = Array.isArray(newVal) && Array.isArray(imp.answers)
          ? newVal.map(ix => escapeHTML(imp.answers[ix] || '')).join('<br>') : '';
      } else {
        oldDisplay = formatVal(oldVal);
        newDisplay = formatVal(newVal);
      }
      const diffClassOld = oldDisplay !== newDisplay ? 'diff-old' : '';
      const diffClassNew = oldDisplay !== newDisplay ? 'diff-new' : '';
      html += `<td class="${diffClassOld}">${oldDisplay}</td>`;
      html += `<td class="${diffClassNew}">${newDisplay}</td>`;
      if (fi === 0) {
        html += `<td rowspan="${fields.length}"><select id="dup-action-${idx}">
          <option value="skip">Do not import</option>
          <option value="replace">Import (replace)</option>
        </select></td>`;
      }
      html += `</tr>`;
    });
  });
  html += `</tbody></table></div>`;
  html += `<div style="margin-top:16px; display:flex; gap:8px; flex-wrap:wrap;">
    <button type="button" onclick="applyDuplicateActions()">Apply</button>
    <button type="button" onclick="showImport()">Back</button>
  </div>`;
  container.innerHTML = html;
  showOnly('importer');
}

/*
 * Applies the actions selected in the duplicate conflict table. Questions marked as
 * "replace" overwrite the existing entries, whereas those marked as "skip" are not
 * imported. Questions without conflicts are imported as new. Progress and history
 * of existing questions are preserved during replacements.
 */
function applyDuplicateActions() {
  loadQuestions();
  const fullList = window._dupFullList || [];
  const collisions = window._dupCollisions || [];
  const byId = new Map(questions.map(q => [q.id, q]));
  const existingNrs = new Set(questions.map(q => parseInt(q.nr) || 0));
  let inserted = 0, updated = 0, skipped = 0;
  // Create a map of collision ids to their selected action
  const actions = {};
  collisions.forEach((imp, idx) => {
    const sel = document.getElementById(`dup-action-${idx}`);
    actions[imp.id] = sel ? sel.value : 'skip';
  });
  for (const imp of fullList) {
    const q = { ...imp };
    if (!q.id) q.id = generateId();
    if (!Array.isArray(q.history)) q.history = [];
    if (byId.has(q.id)) {
      // update or skip based on selection
      if (actions[q.id] === 'replace') {
        const idx = questions.findIndex(x => x.id === q.id);
        if (idx >= 0) {
          const existing = questions[idx];
          const preservedNr = existing.nr;
          const merged = {
            ...existing,
            topic: (q.topic ?? existing.topic) || '',
            text: (q.text ?? existing.text) || '',
            answers: (Array.isArray(q.answers) && q.answers.length ? q.answers : existing.answers) || [],
            solution: (Array.isArray(q.solution) && q.solution.length ? q.solution : existing.solution) || [],
            comment: (q.comment !== undefined ? q.comment : existing.comment) || '',
            difficulty: (q.difficulty || existing.difficulty || 'leicht'),
            progress: (typeof existing.progress === 'number' ? existing.progress : 0),
            lastAnswered: existing.lastAnswered || null,
            history: Array.isArray(existing.history) ? existing.history : [],
            id: existing.id,
            nr: preservedNr,
            createdAt: existing.createdAt || q.createdAt || new Date().toISOString(),
            updatedAt: new Date().toISOString(),
          };
          questions[idx] = merged;
          updated++;
        }
      } else {
        skipped++;
      }
    } else {
      // insert new question
      let nr = parseInt(q.nr) || 1;
      while (existingNrs.has(nr)) nr++;
      existingNrs.add(nr);
      q.nr = nr;
      questions.push({
        id: q.id,
        nr: q.nr,
        topic: q.topic || '',
        text: q.text || '',
        answers: Array.isArray(q.answers) ? q.answers : [],
        solution: Array.isArray(q.solution) ? q.solution : [],
        comment: q.comment || '',
        difficulty: q.difficulty || 'leicht',
        progress: parseInt(q.progress) || 0,
        lastAnswered: q.lastAnswered || null,
        history: Array.isArray(q.history) ? q.history : [],
        createdAt: q.createdAt || new Date().toISOString(),
        updatedAt: q.updatedAt || new Date().toISOString(),
      });
      inserted++;
    }
  }
  saveQuestions();
  // Clear temporary globals
  window._dupFullList = null;
  window._dupCollisions = null;
  showEditor();
  alert(
    '‚úÖ Import completed.\n' +
    'New: ' + inserted + '\n' +
    'Updated: ' + updated + '\n' +
    (skipped ? 'Skipped: ' + skipped + '\n' : '')
  );
}
async function confirmImport(strList) {
  // 1) Liste parsen
  let list = typeof strList === 'string'
    ? JSON.parse(strList.replace(/&quot;/g,'"').replace(/&#39;/g,"'"))
    : strList;

  loadQuestions();

  const byId = new Map(questions.map(q => [q.id, q]));
  const existingNrs = new Set(questions.map(q => parseInt(q.nr)||0));

  // 2) Check for collisions (existing IDs)
  const collisions = (list || []).filter(q => q && q.id && byId.has(q.id));
  if (collisions.length > 0) {
    // Show detailed duplicate resolution UI instead of a simple confirmation
    showDuplicateTable(list, collisions);
    return;
  }

  // 3) Import directly if there are no collisions
  let inserted = 0;
  for (const imp of list) {
    const q = { ...imp };

    // ensure id and history
    if (!q.id) q.id = generateId();
    if (!Array.isArray(q.history)) q.history = [];

    if (byId.has(q.id)) {
      // Should not happen because we returned above when collisions exist
      continue;
    }

    // assign unique running number
    let nr = parseInt(q.nr) || 1;
    while (existingNrs.has(nr)) nr++;
    existingNrs.add(nr);
    q.nr = nr;

    questions.push({
      id: q.id,
      nr: q.nr,
      topic: q.topic || '',
      text: q.text || '',
      answers: Array.isArray(q.answers) ? q.answers : [],
      solution: Array.isArray(q.solution) ? q.solution : [],
      comment: q.comment || '',
      difficulty: q.difficulty || 'leicht',
      progress: parseInt(q.progress) || 0,
      lastAnswered: q.lastAnswered || null,
      history: Array.isArray(q.history) ? q.history : [],
      createdAt: q.createdAt || new Date().toISOString(),
      updatedAt: q.updatedAt || new Date().toISOString(),
    });
    inserted++;
  }
  saveQuestions();
  showEditor();
  await alert(
    `‚úÖ Import completed.\n` +
    `New: ${inserted}`
  );
}


/* ===== Quiz ===== */
function showQuizInit() {
  loadQuestions();
  let topics = [...new Set(questions.map(q=>q.topic).filter(Boolean))];
  let html = `<h3>Start Quiz</h3>
    <div class="quiz-top">
      <label>Topic: 
        <select id="qtopic">
          <option value="">All</option>
          ${topics.map(t=>`<option>${escapeHTML(t)}</option>`).join('')}
        </select>
      </label>
      <label>Difficulty: 
        <select id="qdifficulty">
          <option value="">All</option>
          <option value="leicht">easy</option>
          <option value="schwer">hard</option>
        </select>
      </label>
      <label>Number: 
        <select id="qcount">
          <option value="10">10</option>
          <option value="20">20</option>
          <option value="30">30</option>
          <option value="40">40</option>
          <option value="60">60</option>
          <option value="all" selected>All</option>
        </select>
      </label>
    </div>
    <!-- Suchleiste f√ºr Quiz -->
    <div class="quiz-searchbar" style="display:flex; gap:8px; align-items:center; margin:12px 0;">
      <input id="quiz-search" type="text" placeholder="Search questions¬†‚Ä¶" style="flex:1; min-width:200px;" value="${escapeHTML(quizSearch.text || '')}">
      <button type="button" id="quiz-search-clear" title="Clear search">‚úï</button>
      <span id="quiz-search-count" style="opacity:.75; font-size:.9em;"></span>
    </div>
    <button type="button" onclick="startQuiz()">Start Quiz</button>
    <button type="button" onclick="location.reload()">Back to dashboard</button>`;
  document.getElementById('main').innerHTML = html;
  showOnly('main');
  // Suchfeld initialisieren und Treffer anzeigen
  setupQuizSearch();
}


let editContext = 'database'; // ‚Äûdatabase‚Äú oder ‚Äûquiz‚Äú

async function startQuiz() {
  const topic = document.getElementById('qtopic').value;
  const dif   = document.getElementById('qdifficulty').value;
  const countVal = (document.getElementById('qcount')?.value) || 'all';
  const limit = countVal === 'all' ? Infinity : parseInt(countVal, 10);

  const search = (quizSearch && quizSearch.text || '').trim().toLowerCase();
  const filtered = questions.filter(q =>
    (!topic || q.topic === topic) &&
    (!dif   || q.difficulty === dif) &&
    (!search || matchesQuizSearch(q, search))
  );
  if (filtered.length < 1) { await alert('No questions available for the selection!'); return; }

  const sorted = filtered
    .map(q => ({
      q,
      p: Number(q.progress) || 0,
      hasLA: !!q.lastAnswered,
      ts: q.lastAnswered ? new Date(q.lastAnswered).getTime() : Number.POSITIVE_INFINITY,
      r: Math.random()
    }))
    .sort((a, b) =>
      (a.p - b.p) ||
      ((a.hasLA ? 1 : 0) - (b.hasLA ? 1 : 0)) ||
      (a.ts - b.ts) ||
      (a.r - b.r)
    )
    .map(x => x.q);

  // Auswahl auf gew√ºnschte Anzahl begrenzen (oder alles)
  quizList = (limit === Infinity) ? sorted : sorted.slice(0, Math.min(sorted.length, limit));
  quizIdx = 0;
  quizProg = 0;

  showOnly('quiz-card');
  showQuizCard();
}


function showQuizCard() {
  if (quizIdx >= quizList.length) { endQuiz(); return; }
  if (!quizList || !Array.isArray(quizList) || quizList.length === 0) {
    console.error('quizList is not available');
    alert('Error: quiz list not loaded. Please restart the quiz.');
    hideAll(); return;
  }

  current = quizList[quizIdx];
  if (!current || !current.answers || !Array.isArray(current.answers)) {
    console.error('Current question is invalid:', current);
    alert('Error: question could not be loaded. Please restart the quiz.');
    hideAll(); return;
  }

  quizAnsOrder = Array.from(current.answers.keys()).sort(() => Math.random() - 0.5);

  const q = current, num = quizIdx + 1;
  // translate internal difficulty values ("leicht" and "schwer") to English labels
  const diffLabel = q.difficulty === 'leicht' ? 'easy' : q.difficulty === 'schwer' ? 'hard' : (q.difficulty || '-');
  let html = `<div style="font-size:1.0em; margin-bottom:8px;">
    <strong>No.:</strong> ${escapeHTML(q.nr || '-')} |
    <strong>Topic:</strong> ${escapeHTML(q.topic || '-')} |
    <strong>Difficulty:</strong> ${escapeHTML(diffLabel)} |
    <strong>Question</strong> ${num}/${quizList.length}
  </div>
  <h4 style="font-size: 1.2em;">${renderHTML(q.text)}</h4>
  <div id="qform">`;
  quizAnsOrder.forEach(key => {
    html += `<label class="answer">
      <input type="checkbox" name="ans" value="${key}"> <span class="anshtml">${renderHTML(q.answers[key])}</span>
      </label>`;
  });
  html += `</div>
    <button type="button" id="check-btn" onclick="checkQuizAnswer()">Check</button>
    <button type="button" onclick="previousQuizQuestion()" ${quizIdx === 0 ? 'disabled' : ''}>‚Üê Previous question</button>
    <button type="button" onclick="nextQuizQuestion()">Next question ‚Üí</button>
    <button type="button" onclick="editCurrentQuestion()">‚úèÔ∏è Edit</button>
    <button type="button" onclick="endQuiz()">Cancel</button>
    <div id="result"></div>`;

  document.getElementById('quiz-card').innerHTML = html;
  {
    const progEl = document.getElementById('progress');
    if (progEl) {
      // Show progress on the left and the dataset file name and last modification date on the right.
      const fileInfo = (datasetName ? datasetName : '') + (datasetLastModified ? ' | ' + datasetLastModified : '');
      progEl.innerHTML = `<span>Progress: ${quizProg}/${quizList.length}</span><span>${fileInfo}</span>`;
    }
  }

  // Pr√ºfen-Status resetten
  quizCheckedOnce = false;
  const checkBtn = document.getElementById('check-btn');
  if (checkBtn) checkBtn.disabled = false;
}

function previousQuizQuestion(){ if (quizIdx > 0) { quizIdx--; showQuizCard(); } }
function nextQuizQuestion(){ quizIdx++; showQuizCard(); }

function editCurrentQuestion() {
  if (!current) { alert('No question loaded.'); return; }
  editContext = 'quiz';
  const questionIndex = questions.findIndex(q => q.id === current.id);
  if (questionIndex === -1) { alert('Frage konnte nicht in der Datenbank gefunden werden.'); return; }
  showEditDialog(questions[questionIndex], questionIndex);
}
function editQuestionFromDatabase(idx) { editContext = 'database'; showEditDialog(questions[idx], idx); }

async function saveEdit(idx) {
  const qid = document.getElementById("qid").value || generateId();
  const nr = parseInt(document.getElementById("nr").value) || nextNr();
  const topic = document.getElementById("topic").value.trim();
  const text = sanitizeHTML(document.getElementById("qtext").innerHTML);
  const comment = sanitizeHTML(document.getElementById("qcomment").innerHTML);
  // Bestimme den Schwierigkeitswert aus dem Bearbeitungsdialog. Wenn das Element
  // mit der eindeutigen ID (#ed-qdifficulty) vorhanden ist, verwende dieses.
  // Fallback: Falls das alte #qdifficulty verwendet wird, dessen Wert nutzen
  // (nur f√ºr Abw√§rtskompatibilit√§t).
  let difficulty = '';
  const diffSelect = document.getElementById("ed-qdifficulty");
  if (diffSelect) difficulty = diffSelect.value;
  else {
    const oldSelect = document.getElementById("qdifficulty");
    if (oldSelect) difficulty = oldSelect.value;
  }
  const progress = parseInt(document.getElementById("qprogress").value) || 0;

  let answers = [], solution = [];
  document.querySelectorAll("#answers .answer").forEach((el)=>{
    const box = el.querySelector('.anstxt');
    const chk = el.querySelector('.chk');
    const html = sanitizeHTML(box.innerHTML).trim();
    if (stripHTML(html).length > 0) {
      const newIndex = answers.push(html) - 1;
      if (chk.checked) solution.push(newIndex);
    }
  });

  if (stripHTML(text).length === 0 || answers.length < 2) {
    await alert("Please enter the question and at least 2 answer options.");
    return;
  }
  if (solution.length < 1) { await alert("At least one answer must be marked as correct!"); return; }

  let createdAt    = (idx >= 0 && questions[idx]) ? questions[idx].createdAt : new Date().toISOString();
  let lastAnswered = (idx >= 0 && questions[idx]) ? questions[idx].lastAnswered : null;
  let history      = (idx >= 0 && Array.isArray(questions[idx].history)) ? questions[idx].history : [];

  const q = { id: qid, nr, topic, text, answers, solution, comment, difficulty, progress,
              createdAt, updatedAt: new Date().toISOString(), lastAnswered, history };

  if (idx >= 0) questions[idx] = q; else questions.push(q);

  saveEditorScroll(qid); // Position im Editor merken
  saveQuestions();
  closeModal();

  if (editContext === 'quiz') {
    const i = quizList.findIndex(x => x.id === q.id);
    if (i >= 0) quizList[i] = q;
    current = q;
    showQuizCard();
  } else {
    showEditor();
  }
}


/* Pr√ºfen */
function checkQuizAnswer() {
  if (quizCheckedOnce) return;
  quizCheckedOnce = true;
  const checkBtnEl = document.getElementById('check-btn');
  if (checkBtnEl) { checkBtnEl.disabled = true; checkBtnEl.setAttribute('aria-disabled','true'); }

  if (!current) { console.error('current is null'); alert('Error: quiz not loaded properly.'); return; }

  let q = questions.find(qq => qq.id === current.id) || current;

  let sel = Array.from(document.querySelectorAll('input[name=ans]:checked')).map(inp => parseInt(inp.value));
  let solution = q.solution || [];
  let isCorrect = JSON.stringify(sel.slice().sort()) === JSON.stringify(solution.slice().sort());

  // Build main result string with English messages
  let mainResult = isCorrect
    ? '<strong class="correct">‚úÖ Correct!</strong>'
    : '<strong class="wrong">‚ùå Incorrect!</strong>';

  if (isCorrect) {
    q.progress = (q.progress || 0) + 1;
    quizProg++;
    // Lern-History Ereignis hinzuf√ºgen
    if (!Array.isArray(q.history)) q.history = [];
    q.history.push({ ts: new Date().toISOString(), delta: 1 });
  }
  q.lastAnswered = new Date().toISOString();
  // in DB zur√ºckschreiben
  const qi = questions.findIndex(qq => qq.id === q.id);
  if (qi >= 0) questions[qi] = q;
  saveQuestions();

  // Anzeige der L√∂sung
  let solutionHtml = `
    <div style="display: flex; align-items: center; gap: 18px; margin-bottom: 12px;">
      <span style="font-size: 1.1em; font-weight: bold; color: color-mix(in srgb, CanvasText 30%, blue 70%);">üìã Explanation:</span>
      <span>${mainResult}</span>
    </div>`;

  let answersHtml = "";
  quizAnsOrder.forEach((key) => {
    let idx = parseInt(key);
    let isCorrectAnswer = solution.includes(idx);
    let wasSelected = sel.includes(idx);
    let displayText = '';
    let styleClass = '';
  if (isCorrectAnswer && wasSelected) {
    displayText = `‚úÖ ${renderHTML(q.answers[idx])} <em style="opacity: 0.8;">(correctly chosen)</em>`;
    styleClass = 'correct';
  } else if (isCorrectAnswer && !wasSelected) {
    displayText = `‚úì ${renderHTML(q.answers[idx])} <em style="opacity: 0.8;">(correct answer, not chosen)</em>`;
    styleClass = 'correct';
  } else if (!isCorrectAnswer && wasSelected) {
    displayText = `‚ùå ${renderHTML(q.answers[idx])} <em style="opacity: 0.8;">(incorrectly chosen)</em>`;
    styleClass = 'wrong';
  } else {
  return;
}

    answersHtml += `<div style="margin: 8px 0; padding: 8px 12px; border-radius: 6px; border-left: 3px solid; background: color-mix(in srgb, Field 80%, ${styleClass === 'correct' ? 'green' : 'red'} 20%); border-left-color: color-mix(in srgb, CanvasText 30%, ${styleClass === 'correct' ? 'green' : 'red'} 70%); color: color-mix(in srgb, CanvasText 20%, ${styleClass === 'correct' ? 'green' : 'red'} 80%);">${displayText}</div>`;
  });

  const rawComment = q.comment || "";
  const hasContent = stripHTML(rawComment).trim().length > 0;
  const looksLikeHtml = /<\s*\w+/i.test(rawComment);
  
  let normalized = looksLikeHtml ? rawComment : rawComment.replace(/\n/g, '<br>');
  const commentHtml = `
    <div style="margin-top: 16px; padding: 12px; border-radius: 8px; border: 1px solid;">
    <div style="font-size: 1.1em; font-weight: bold; margin-bottom: 12px; color: color-mix(in srgb, CanvasText 30%, blue 70%);">Comment:</div>
    <div class="comment-body" style="margin-top: 12px; color: var(--text);">
      ${hasContent ? renderHTML(normalized) : '<em>No comment available.</em>'}
    </div>
  </div>`;



  let result = `<div style="margin-top: 16px; padding: 12px; border-radius: 8px; border: 1px solid;">${solutionHtml}${answersHtml}</div>${commentHtml}`;
  const resultEl = document.getElementById('result');
  if (resultEl) resultEl.innerHTML = result;
  const progEl = document.getElementById('progress');
  if (progEl) {
    // Zeige links den Fortschritt und rechts den Dateinamen sowie das letzte √Ñnderungsdatum.
    const fileInfo = (datasetName ? datasetName : '') + (datasetLastModified ? ' | ' + datasetLastModified : '');
    progEl.innerHTML = `<span>Progress: ${quizProg}/${quizList.length}</span><span>${fileInfo}</span>`;
  }
}

function endQuiz() {
  showOnly('main');
  document.getElementById('main').innerHTML = `<h2>The quiz is finished.</h2>
    <p>Your progress: <strong>${quizProg}/${quizList.length}</strong></p>
    <button type="button" onclick="location.reload()">Back to dashboard</button>`;
}

/* ===== Reset / Init ===== */
async function resetCache() {
  if (await confirm("Reset quiz settings?\n\n‚úÖ Only affects the quiz\n‚úÖ Questions remain intact\n‚úÖ Other websites unaffected")) {
    localStorage.removeItem('quiz_settings');
    await alert("‚úÖ Quiz settings have been reset!");
    location.reload();
  }
}
async function resetAllData() {
  if (await confirm("‚ö†Ô∏è Delete all quiz data?\n\n‚Ä¢ Quiz questions\n‚Ä¢ Quiz settings\n‚Ä¢ Quiz progress\n\n‚úÖ Only affects the quiz\n‚úÖ Other websites unaffected")) {
    if (await confirm("üî¥ FINAL WARNING: All quiz data will be deleted!\n\nProceed?")) {
      localStorage.removeItem('quizdb_v2');
      localStorage.removeItem('quiz_settings');
      // Also remove stored dataset info so the progress bar no longer shows outdated information.
      updateDatasetInfo('', '', '');
      await alert("‚úÖ Quiz data has been deleted!");
      location.reload();
    }
  }
}

/* Init */
function initializeDashboard(){ loadDashboardSettings(); updateDashboard(); }
// Initialisiere das Dashboard und lege die Floating‚ÄëToolbox (RTE) genau einmal an.
// Wir verbinden beide vormals separaten DOMContentLoaded‚ÄëHandler in einem einzigen,
// damit `initFloatingRte()` garantiert ausgef√ºhrt wird und keine mehrfachen
// Initialisierungen passieren. Siehe MDN zur DOMContentLoaded‚ÄëEvent.
document.addEventListener('DOMContentLoaded', () => {
  // Dashboard laden (Fragen, Statistik, etc.)
  initializeDashboard();
  // Toolbox anlegen: erst beim ersten Fokus wird sie sichtbar, aber sie muss
  // im DOM vorhanden sein, damit showRte() sie finden kann.
  initFloatingRte();
});
</script>
</body>
</html>
